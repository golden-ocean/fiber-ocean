// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/golden-ocean/fiber-ocean/ent/dictionary"
	"github.com/golden-ocean/fiber-ocean/ent/dictionary_item"
	"github.com/golden-ocean/fiber-ocean/ent/menu"
	"github.com/golden-ocean/fiber-ocean/ent/organization"
	"github.com/golden-ocean/fiber-ocean/ent/position"
	"github.com/golden-ocean/fiber-ocean/ent/predicate"
	"github.com/golden-ocean/fiber-ocean/ent/role"
	"github.com/golden-ocean/fiber-ocean/ent/role_menu"
	"github.com/golden-ocean/fiber-ocean/ent/role_organization"
	"github.com/golden-ocean/fiber-ocean/ent/staff"
	"github.com/golden-ocean/fiber-ocean/ent/staff_position"
	"github.com/golden-ocean/fiber-ocean/ent/staff_role"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDictionary       = "Dictionary"
	TypeDictionaryItem   = "Dictionary_Item"
	TypeMenu             = "Menu"
	TypeOrganization     = "Organization"
	TypePosition         = "Position"
	TypeRole             = "Role"
	TypeRoleMenu         = "Role_Menu"
	TypeRoleOrganization = "Role_Organization"
	TypeStaff            = "Staff"
	TypeStaffPosition    = "Staff_Position"
	TypeStaffRole        = "Staff_Role"
)

// DictionaryMutation represents an operation that mutates the Dictionary nodes in the graph.
type DictionaryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *int64
	addcreated_at *int64
	updated_at    *int64
	addupdated_at *int64
	created_by    *string
	updated_by    *string
	status        *string
	sort          *int32
	addsort       *int32
	remark        *string
	name          *string
	code          *string
	clearedFields map[string]struct{}
	items         map[string]struct{}
	removeditems  map[string]struct{}
	cleareditems  bool
	done          bool
	oldValue      func(context.Context) (*Dictionary, error)
	predicates    []predicate.Dictionary
}

var _ ent.Mutation = (*DictionaryMutation)(nil)

// dictionaryOption allows management of the mutation configuration using functional options.
type dictionaryOption func(*DictionaryMutation)

// newDictionaryMutation creates new mutation for the Dictionary entity.
func newDictionaryMutation(c config, op Op, opts ...dictionaryOption) *DictionaryMutation {
	m := &DictionaryMutation{
		config:        c,
		op:            op,
		typ:           TypeDictionary,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDictionaryID sets the ID field of the mutation.
func withDictionaryID(id string) dictionaryOption {
	return func(m *DictionaryMutation) {
		var (
			err   error
			once  sync.Once
			value *Dictionary
		)
		m.oldValue = func(ctx context.Context) (*Dictionary, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dictionary.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDictionary sets the old Dictionary of the mutation.
func withDictionary(node *Dictionary) dictionaryOption {
	return func(m *DictionaryMutation) {
		m.oldValue = func(context.Context) (*Dictionary, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DictionaryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DictionaryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Dictionary entities.
func (m *DictionaryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DictionaryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DictionaryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Dictionary.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DictionaryMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DictionaryMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *DictionaryMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *DictionaryMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DictionaryMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DictionaryMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DictionaryMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *DictionaryMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *DictionaryMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DictionaryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *DictionaryMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DictionaryMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *DictionaryMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[dictionary.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *DictionaryMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[dictionary.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DictionaryMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, dictionary.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DictionaryMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DictionaryMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *DictionaryMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[dictionary.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *DictionaryMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[dictionary.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DictionaryMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, dictionary.FieldUpdatedBy)
}

// SetStatus sets the "status" field.
func (m *DictionaryMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *DictionaryMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *DictionaryMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[dictionary.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *DictionaryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[dictionary.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *DictionaryMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, dictionary.FieldStatus)
}

// SetSort sets the "sort" field.
func (m *DictionaryMutation) SetSort(i int32) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *DictionaryMutation) Sort() (r int32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldSort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *DictionaryMutation) AddSort(i int32) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *DictionaryMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ClearSort clears the value of the "sort" field.
func (m *DictionaryMutation) ClearSort() {
	m.sort = nil
	m.addsort = nil
	m.clearedFields[dictionary.FieldSort] = struct{}{}
}

// SortCleared returns if the "sort" field was cleared in this mutation.
func (m *DictionaryMutation) SortCleared() bool {
	_, ok := m.clearedFields[dictionary.FieldSort]
	return ok
}

// ResetSort resets all changes to the "sort" field.
func (m *DictionaryMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
	delete(m.clearedFields, dictionary.FieldSort)
}

// SetRemark sets the "remark" field.
func (m *DictionaryMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *DictionaryMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *DictionaryMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[dictionary.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *DictionaryMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[dictionary.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *DictionaryMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, dictionary.FieldRemark)
}

// SetName sets the "name" field.
func (m *DictionaryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DictionaryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DictionaryMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *DictionaryMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *DictionaryMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Dictionary entity.
// If the Dictionary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *DictionaryMutation) ResetCode() {
	m.code = nil
}

// AddItemIDs adds the "items" edge to the Dictionary_Item entity by ids.
func (m *DictionaryMutation) AddItemIDs(ids ...string) {
	if m.items == nil {
		m.items = make(map[string]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the Dictionary_Item entity.
func (m *DictionaryMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the Dictionary_Item entity was cleared.
func (m *DictionaryMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the Dictionary_Item entity by IDs.
func (m *DictionaryMutation) RemoveItemIDs(ids ...string) {
	if m.removeditems == nil {
		m.removeditems = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the Dictionary_Item entity.
func (m *DictionaryMutation) RemovedItemsIDs() (ids []string) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *DictionaryMutation) ItemsIDs() (ids []string) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *DictionaryMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// Where appends a list predicates to the DictionaryMutation builder.
func (m *DictionaryMutation) Where(ps ...predicate.Dictionary) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DictionaryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DictionaryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Dictionary, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DictionaryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DictionaryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Dictionary).
func (m *DictionaryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DictionaryMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, dictionary.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dictionary.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, dictionary.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, dictionary.FieldUpdatedBy)
	}
	if m.status != nil {
		fields = append(fields, dictionary.FieldStatus)
	}
	if m.sort != nil {
		fields = append(fields, dictionary.FieldSort)
	}
	if m.remark != nil {
		fields = append(fields, dictionary.FieldRemark)
	}
	if m.name != nil {
		fields = append(fields, dictionary.FieldName)
	}
	if m.code != nil {
		fields = append(fields, dictionary.FieldCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DictionaryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dictionary.FieldCreatedAt:
		return m.CreatedAt()
	case dictionary.FieldUpdatedAt:
		return m.UpdatedAt()
	case dictionary.FieldCreatedBy:
		return m.CreatedBy()
	case dictionary.FieldUpdatedBy:
		return m.UpdatedBy()
	case dictionary.FieldStatus:
		return m.Status()
	case dictionary.FieldSort:
		return m.Sort()
	case dictionary.FieldRemark:
		return m.Remark()
	case dictionary.FieldName:
		return m.Name()
	case dictionary.FieldCode:
		return m.Code()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DictionaryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dictionary.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dictionary.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dictionary.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case dictionary.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case dictionary.FieldStatus:
		return m.OldStatus(ctx)
	case dictionary.FieldSort:
		return m.OldSort(ctx)
	case dictionary.FieldRemark:
		return m.OldRemark(ctx)
	case dictionary.FieldName:
		return m.OldName(ctx)
	case dictionary.FieldCode:
		return m.OldCode(ctx)
	}
	return nil, fmt.Errorf("unknown Dictionary field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dictionary.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dictionary.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dictionary.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case dictionary.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case dictionary.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case dictionary.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case dictionary.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case dictionary.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case dictionary.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	}
	return fmt.Errorf("unknown Dictionary field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DictionaryMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, dictionary.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, dictionary.FieldUpdatedAt)
	}
	if m.addsort != nil {
		fields = append(fields, dictionary.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DictionaryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dictionary.FieldCreatedAt:
		return m.AddedCreatedAt()
	case dictionary.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case dictionary.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dictionary.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case dictionary.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case dictionary.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown Dictionary numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DictionaryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dictionary.FieldCreatedBy) {
		fields = append(fields, dictionary.FieldCreatedBy)
	}
	if m.FieldCleared(dictionary.FieldUpdatedBy) {
		fields = append(fields, dictionary.FieldUpdatedBy)
	}
	if m.FieldCleared(dictionary.FieldStatus) {
		fields = append(fields, dictionary.FieldStatus)
	}
	if m.FieldCleared(dictionary.FieldSort) {
		fields = append(fields, dictionary.FieldSort)
	}
	if m.FieldCleared(dictionary.FieldRemark) {
		fields = append(fields, dictionary.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DictionaryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DictionaryMutation) ClearField(name string) error {
	switch name {
	case dictionary.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case dictionary.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case dictionary.FieldStatus:
		m.ClearStatus()
		return nil
	case dictionary.FieldSort:
		m.ClearSort()
		return nil
	case dictionary.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Dictionary nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DictionaryMutation) ResetField(name string) error {
	switch name {
	case dictionary.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dictionary.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dictionary.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case dictionary.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case dictionary.FieldStatus:
		m.ResetStatus()
		return nil
	case dictionary.FieldSort:
		m.ResetSort()
		return nil
	case dictionary.FieldRemark:
		m.ResetRemark()
		return nil
	case dictionary.FieldName:
		m.ResetName()
		return nil
	case dictionary.FieldCode:
		m.ResetCode()
		return nil
	}
	return fmt.Errorf("unknown Dictionary field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DictionaryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.items != nil {
		edges = append(edges, dictionary.EdgeItems)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DictionaryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dictionary.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DictionaryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeditems != nil {
		edges = append(edges, dictionary.EdgeItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DictionaryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case dictionary.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DictionaryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareditems {
		edges = append(edges, dictionary.EdgeItems)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DictionaryMutation) EdgeCleared(name string) bool {
	switch name {
	case dictionary.EdgeItems:
		return m.cleareditems
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DictionaryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Dictionary unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DictionaryMutation) ResetEdge(name string) error {
	switch name {
	case dictionary.EdgeItems:
		m.ResetItems()
		return nil
	}
	return fmt.Errorf("unknown Dictionary edge %s", name)
}

// DictionaryItemMutation represents an operation that mutates the Dictionary_Item nodes in the graph.
type DictionaryItemMutation struct {
	config
	op                Op
	typ               string
	id                *string
	created_at        *int64
	addcreated_at     *int64
	updated_at        *int64
	addupdated_at     *int64
	created_by        *string
	updated_by        *string
	status            *string
	sort              *int32
	addsort           *int32
	remark            *string
	label             *string
	value             *string
	color             *string
	clearedFields     map[string]struct{}
	dictionary        *string
	cleareddictionary bool
	done              bool
	oldValue          func(context.Context) (*Dictionary_Item, error)
	predicates        []predicate.Dictionary_Item
}

var _ ent.Mutation = (*DictionaryItemMutation)(nil)

// dictionaryItemOption allows management of the mutation configuration using functional options.
type dictionaryItemOption func(*DictionaryItemMutation)

// newDictionaryItemMutation creates new mutation for the Dictionary_Item entity.
func newDictionaryItemMutation(c config, op Op, opts ...dictionaryItemOption) *DictionaryItemMutation {
	m := &DictionaryItemMutation{
		config:        c,
		op:            op,
		typ:           TypeDictionaryItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDictionary_ItemID sets the ID field of the mutation.
func withDictionary_ItemID(id string) dictionaryItemOption {
	return func(m *DictionaryItemMutation) {
		var (
			err   error
			once  sync.Once
			value *Dictionary_Item
		)
		m.oldValue = func(ctx context.Context) (*Dictionary_Item, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Dictionary_Item.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDictionary_Item sets the old Dictionary_Item of the mutation.
func withDictionary_Item(node *Dictionary_Item) dictionaryItemOption {
	return func(m *DictionaryItemMutation) {
		m.oldValue = func(context.Context) (*Dictionary_Item, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DictionaryItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DictionaryItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Dictionary_Item entities.
func (m *DictionaryItemMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DictionaryItemMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DictionaryItemMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Dictionary_Item.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DictionaryItemMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DictionaryItemMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Dictionary_Item entity.
// If the Dictionary_Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryItemMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *DictionaryItemMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *DictionaryItemMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DictionaryItemMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DictionaryItemMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DictionaryItemMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Dictionary_Item entity.
// If the Dictionary_Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryItemMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *DictionaryItemMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *DictionaryItemMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DictionaryItemMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *DictionaryItemMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DictionaryItemMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Dictionary_Item entity.
// If the Dictionary_Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryItemMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *DictionaryItemMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[dictionary_item.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *DictionaryItemMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[dictionary_item.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DictionaryItemMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, dictionary_item.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DictionaryItemMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DictionaryItemMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Dictionary_Item entity.
// If the Dictionary_Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryItemMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *DictionaryItemMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[dictionary_item.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *DictionaryItemMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[dictionary_item.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DictionaryItemMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, dictionary_item.FieldUpdatedBy)
}

// SetStatus sets the "status" field.
func (m *DictionaryItemMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *DictionaryItemMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Dictionary_Item entity.
// If the Dictionary_Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryItemMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *DictionaryItemMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[dictionary_item.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *DictionaryItemMutation) StatusCleared() bool {
	_, ok := m.clearedFields[dictionary_item.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *DictionaryItemMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, dictionary_item.FieldStatus)
}

// SetSort sets the "sort" field.
func (m *DictionaryItemMutation) SetSort(i int32) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *DictionaryItemMutation) Sort() (r int32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Dictionary_Item entity.
// If the Dictionary_Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryItemMutation) OldSort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *DictionaryItemMutation) AddSort(i int32) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *DictionaryItemMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ClearSort clears the value of the "sort" field.
func (m *DictionaryItemMutation) ClearSort() {
	m.sort = nil
	m.addsort = nil
	m.clearedFields[dictionary_item.FieldSort] = struct{}{}
}

// SortCleared returns if the "sort" field was cleared in this mutation.
func (m *DictionaryItemMutation) SortCleared() bool {
	_, ok := m.clearedFields[dictionary_item.FieldSort]
	return ok
}

// ResetSort resets all changes to the "sort" field.
func (m *DictionaryItemMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
	delete(m.clearedFields, dictionary_item.FieldSort)
}

// SetRemark sets the "remark" field.
func (m *DictionaryItemMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *DictionaryItemMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Dictionary_Item entity.
// If the Dictionary_Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryItemMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *DictionaryItemMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[dictionary_item.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *DictionaryItemMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[dictionary_item.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *DictionaryItemMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, dictionary_item.FieldRemark)
}

// SetLabel sets the "label" field.
func (m *DictionaryItemMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *DictionaryItemMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the Dictionary_Item entity.
// If the Dictionary_Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryItemMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *DictionaryItemMutation) ResetLabel() {
	m.label = nil
}

// SetValue sets the "value" field.
func (m *DictionaryItemMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *DictionaryItemMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Dictionary_Item entity.
// If the Dictionary_Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryItemMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *DictionaryItemMutation) ResetValue() {
	m.value = nil
}

// SetColor sets the "color" field.
func (m *DictionaryItemMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *DictionaryItemMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Dictionary_Item entity.
// If the Dictionary_Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryItemMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ResetColor resets all changes to the "color" field.
func (m *DictionaryItemMutation) ResetColor() {
	m.color = nil
}

// SetDictionaryID sets the "dictionary_id" field.
func (m *DictionaryItemMutation) SetDictionaryID(s string) {
	m.dictionary = &s
}

// DictionaryID returns the value of the "dictionary_id" field in the mutation.
func (m *DictionaryItemMutation) DictionaryID() (r string, exists bool) {
	v := m.dictionary
	if v == nil {
		return
	}
	return *v, true
}

// OldDictionaryID returns the old "dictionary_id" field's value of the Dictionary_Item entity.
// If the Dictionary_Item object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DictionaryItemMutation) OldDictionaryID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDictionaryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDictionaryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDictionaryID: %w", err)
	}
	return oldValue.DictionaryID, nil
}

// ResetDictionaryID resets all changes to the "dictionary_id" field.
func (m *DictionaryItemMutation) ResetDictionaryID() {
	m.dictionary = nil
}

// ClearDictionary clears the "dictionary" edge to the Dictionary entity.
func (m *DictionaryItemMutation) ClearDictionary() {
	m.cleareddictionary = true
	m.clearedFields[dictionary_item.FieldDictionaryID] = struct{}{}
}

// DictionaryCleared reports if the "dictionary" edge to the Dictionary entity was cleared.
func (m *DictionaryItemMutation) DictionaryCleared() bool {
	return m.cleareddictionary
}

// DictionaryIDs returns the "dictionary" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DictionaryID instead. It exists only for internal usage by the builders.
func (m *DictionaryItemMutation) DictionaryIDs() (ids []string) {
	if id := m.dictionary; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDictionary resets all changes to the "dictionary" edge.
func (m *DictionaryItemMutation) ResetDictionary() {
	m.dictionary = nil
	m.cleareddictionary = false
}

// Where appends a list predicates to the DictionaryItemMutation builder.
func (m *DictionaryItemMutation) Where(ps ...predicate.Dictionary_Item) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DictionaryItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DictionaryItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Dictionary_Item, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DictionaryItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DictionaryItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Dictionary_Item).
func (m *DictionaryItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DictionaryItemMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, dictionary_item.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, dictionary_item.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, dictionary_item.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, dictionary_item.FieldUpdatedBy)
	}
	if m.status != nil {
		fields = append(fields, dictionary_item.FieldStatus)
	}
	if m.sort != nil {
		fields = append(fields, dictionary_item.FieldSort)
	}
	if m.remark != nil {
		fields = append(fields, dictionary_item.FieldRemark)
	}
	if m.label != nil {
		fields = append(fields, dictionary_item.FieldLabel)
	}
	if m.value != nil {
		fields = append(fields, dictionary_item.FieldValue)
	}
	if m.color != nil {
		fields = append(fields, dictionary_item.FieldColor)
	}
	if m.dictionary != nil {
		fields = append(fields, dictionary_item.FieldDictionaryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DictionaryItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dictionary_item.FieldCreatedAt:
		return m.CreatedAt()
	case dictionary_item.FieldUpdatedAt:
		return m.UpdatedAt()
	case dictionary_item.FieldCreatedBy:
		return m.CreatedBy()
	case dictionary_item.FieldUpdatedBy:
		return m.UpdatedBy()
	case dictionary_item.FieldStatus:
		return m.Status()
	case dictionary_item.FieldSort:
		return m.Sort()
	case dictionary_item.FieldRemark:
		return m.Remark()
	case dictionary_item.FieldLabel:
		return m.Label()
	case dictionary_item.FieldValue:
		return m.Value()
	case dictionary_item.FieldColor:
		return m.Color()
	case dictionary_item.FieldDictionaryID:
		return m.DictionaryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DictionaryItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dictionary_item.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case dictionary_item.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case dictionary_item.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case dictionary_item.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case dictionary_item.FieldStatus:
		return m.OldStatus(ctx)
	case dictionary_item.FieldSort:
		return m.OldSort(ctx)
	case dictionary_item.FieldRemark:
		return m.OldRemark(ctx)
	case dictionary_item.FieldLabel:
		return m.OldLabel(ctx)
	case dictionary_item.FieldValue:
		return m.OldValue(ctx)
	case dictionary_item.FieldColor:
		return m.OldColor(ctx)
	case dictionary_item.FieldDictionaryID:
		return m.OldDictionaryID(ctx)
	}
	return nil, fmt.Errorf("unknown Dictionary_Item field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dictionary_item.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case dictionary_item.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case dictionary_item.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case dictionary_item.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case dictionary_item.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case dictionary_item.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case dictionary_item.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case dictionary_item.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case dictionary_item.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case dictionary_item.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case dictionary_item.FieldDictionaryID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDictionaryID(v)
		return nil
	}
	return fmt.Errorf("unknown Dictionary_Item field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DictionaryItemMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, dictionary_item.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, dictionary_item.FieldUpdatedAt)
	}
	if m.addsort != nil {
		fields = append(fields, dictionary_item.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DictionaryItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case dictionary_item.FieldCreatedAt:
		return m.AddedCreatedAt()
	case dictionary_item.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case dictionary_item.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DictionaryItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case dictionary_item.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case dictionary_item.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case dictionary_item.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown Dictionary_Item numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DictionaryItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(dictionary_item.FieldCreatedBy) {
		fields = append(fields, dictionary_item.FieldCreatedBy)
	}
	if m.FieldCleared(dictionary_item.FieldUpdatedBy) {
		fields = append(fields, dictionary_item.FieldUpdatedBy)
	}
	if m.FieldCleared(dictionary_item.FieldStatus) {
		fields = append(fields, dictionary_item.FieldStatus)
	}
	if m.FieldCleared(dictionary_item.FieldSort) {
		fields = append(fields, dictionary_item.FieldSort)
	}
	if m.FieldCleared(dictionary_item.FieldRemark) {
		fields = append(fields, dictionary_item.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DictionaryItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DictionaryItemMutation) ClearField(name string) error {
	switch name {
	case dictionary_item.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case dictionary_item.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case dictionary_item.FieldStatus:
		m.ClearStatus()
		return nil
	case dictionary_item.FieldSort:
		m.ClearSort()
		return nil
	case dictionary_item.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Dictionary_Item nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DictionaryItemMutation) ResetField(name string) error {
	switch name {
	case dictionary_item.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case dictionary_item.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case dictionary_item.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case dictionary_item.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case dictionary_item.FieldStatus:
		m.ResetStatus()
		return nil
	case dictionary_item.FieldSort:
		m.ResetSort()
		return nil
	case dictionary_item.FieldRemark:
		m.ResetRemark()
		return nil
	case dictionary_item.FieldLabel:
		m.ResetLabel()
		return nil
	case dictionary_item.FieldValue:
		m.ResetValue()
		return nil
	case dictionary_item.FieldColor:
		m.ResetColor()
		return nil
	case dictionary_item.FieldDictionaryID:
		m.ResetDictionaryID()
		return nil
	}
	return fmt.Errorf("unknown Dictionary_Item field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DictionaryItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.dictionary != nil {
		edges = append(edges, dictionary_item.EdgeDictionary)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DictionaryItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case dictionary_item.EdgeDictionary:
		if id := m.dictionary; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DictionaryItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DictionaryItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DictionaryItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddictionary {
		edges = append(edges, dictionary_item.EdgeDictionary)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DictionaryItemMutation) EdgeCleared(name string) bool {
	switch name {
	case dictionary_item.EdgeDictionary:
		return m.cleareddictionary
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DictionaryItemMutation) ClearEdge(name string) error {
	switch name {
	case dictionary_item.EdgeDictionary:
		m.ClearDictionary()
		return nil
	}
	return fmt.Errorf("unknown Dictionary_Item unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DictionaryItemMutation) ResetEdge(name string) error {
	switch name {
	case dictionary_item.EdgeDictionary:
		m.ResetDictionary()
		return nil
	}
	return fmt.Errorf("unknown Dictionary_Item edge %s", name)
}

// MenuMutation represents an operation that mutates the Menu nodes in the graph.
type MenuMutation struct {
	config
	op              Op
	typ             string
	id              *string
	created_at      *int64
	addcreated_at   *int64
	updated_at      *int64
	addupdated_at   *int64
	created_by      *string
	updated_by      *string
	status          *string
	sort            *int32
	addsort         *int32
	remark          *string
	name            *string
	icon            *string
	_path           *string
	permission      *string
	component       *string
	_type           *string
	method          *string
	visible         *bool
	clearedFields   map[string]struct{}
	parent          *string
	clearedparent   bool
	children        map[string]struct{}
	removedchildren map[string]struct{}
	clearedchildren bool
	roles           map[string]struct{}
	removedroles    map[string]struct{}
	clearedroles    bool
	done            bool
	oldValue        func(context.Context) (*Menu, error)
	predicates      []predicate.Menu
}

var _ ent.Mutation = (*MenuMutation)(nil)

// menuOption allows management of the mutation configuration using functional options.
type menuOption func(*MenuMutation)

// newMenuMutation creates new mutation for the Menu entity.
func newMenuMutation(c config, op Op, opts ...menuOption) *MenuMutation {
	m := &MenuMutation{
		config:        c,
		op:            op,
		typ:           TypeMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMenuID sets the ID field of the mutation.
func withMenuID(id string) menuOption {
	return func(m *MenuMutation) {
		var (
			err   error
			once  sync.Once
			value *Menu
		)
		m.oldValue = func(ctx context.Context) (*Menu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Menu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMenu sets the old Menu of the mutation.
func withMenu(node *Menu) menuOption {
	return func(m *MenuMutation) {
		m.oldValue = func(context.Context) (*Menu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Menu entities.
func (m *MenuMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MenuMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MenuMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Menu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MenuMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MenuMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *MenuMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *MenuMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MenuMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MenuMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MenuMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *MenuMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *MenuMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MenuMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *MenuMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MenuMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *MenuMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[menu.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *MenuMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[menu.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MenuMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, menu.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MenuMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MenuMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *MenuMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[menu.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *MenuMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[menu.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MenuMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, menu.FieldUpdatedBy)
}

// SetStatus sets the "status" field.
func (m *MenuMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *MenuMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *MenuMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[menu.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MenuMutation) StatusCleared() bool {
	_, ok := m.clearedFields[menu.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MenuMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, menu.FieldStatus)
}

// SetSort sets the "sort" field.
func (m *MenuMutation) SetSort(i int32) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *MenuMutation) Sort() (r int32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldSort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *MenuMutation) AddSort(i int32) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *MenuMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ClearSort clears the value of the "sort" field.
func (m *MenuMutation) ClearSort() {
	m.sort = nil
	m.addsort = nil
	m.clearedFields[menu.FieldSort] = struct{}{}
}

// SortCleared returns if the "sort" field was cleared in this mutation.
func (m *MenuMutation) SortCleared() bool {
	_, ok := m.clearedFields[menu.FieldSort]
	return ok
}

// ResetSort resets all changes to the "sort" field.
func (m *MenuMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
	delete(m.clearedFields, menu.FieldSort)
}

// SetRemark sets the "remark" field.
func (m *MenuMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *MenuMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *MenuMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[menu.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *MenuMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[menu.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *MenuMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, menu.FieldRemark)
}

// SetName sets the "name" field.
func (m *MenuMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MenuMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MenuMutation) ResetName() {
	m.name = nil
}

// SetParentID sets the "parent_id" field.
func (m *MenuMutation) SetParentID(s string) {
	m.parent = &s
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *MenuMutation) ParentID() (r string, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldParentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *MenuMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[menu.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *MenuMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[menu.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *MenuMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, menu.FieldParentID)
}

// SetIcon sets the "icon" field.
func (m *MenuMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *MenuMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *MenuMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[menu.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *MenuMutation) IconCleared() bool {
	_, ok := m.clearedFields[menu.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *MenuMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, menu.FieldIcon)
}

// SetPath sets the "path" field.
func (m *MenuMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *MenuMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *MenuMutation) ClearPath() {
	m._path = nil
	m.clearedFields[menu.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *MenuMutation) PathCleared() bool {
	_, ok := m.clearedFields[menu.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *MenuMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, menu.FieldPath)
}

// SetPermission sets the "permission" field.
func (m *MenuMutation) SetPermission(s string) {
	m.permission = &s
}

// Permission returns the value of the "permission" field in the mutation.
func (m *MenuMutation) Permission() (r string, exists bool) {
	v := m.permission
	if v == nil {
		return
	}
	return *v, true
}

// OldPermission returns the old "permission" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldPermission(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermission: %w", err)
	}
	return oldValue.Permission, nil
}

// ClearPermission clears the value of the "permission" field.
func (m *MenuMutation) ClearPermission() {
	m.permission = nil
	m.clearedFields[menu.FieldPermission] = struct{}{}
}

// PermissionCleared returns if the "permission" field was cleared in this mutation.
func (m *MenuMutation) PermissionCleared() bool {
	_, ok := m.clearedFields[menu.FieldPermission]
	return ok
}

// ResetPermission resets all changes to the "permission" field.
func (m *MenuMutation) ResetPermission() {
	m.permission = nil
	delete(m.clearedFields, menu.FieldPermission)
}

// SetComponent sets the "component" field.
func (m *MenuMutation) SetComponent(s string) {
	m.component = &s
}

// Component returns the value of the "component" field in the mutation.
func (m *MenuMutation) Component() (r string, exists bool) {
	v := m.component
	if v == nil {
		return
	}
	return *v, true
}

// OldComponent returns the old "component" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldComponent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComponent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComponent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComponent: %w", err)
	}
	return oldValue.Component, nil
}

// ClearComponent clears the value of the "component" field.
func (m *MenuMutation) ClearComponent() {
	m.component = nil
	m.clearedFields[menu.FieldComponent] = struct{}{}
}

// ComponentCleared returns if the "component" field was cleared in this mutation.
func (m *MenuMutation) ComponentCleared() bool {
	_, ok := m.clearedFields[menu.FieldComponent]
	return ok
}

// ResetComponent resets all changes to the "component" field.
func (m *MenuMutation) ResetComponent() {
	m.component = nil
	delete(m.clearedFields, menu.FieldComponent)
}

// SetType sets the "type" field.
func (m *MenuMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *MenuMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *MenuMutation) ClearType() {
	m._type = nil
	m.clearedFields[menu.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *MenuMutation) TypeCleared() bool {
	_, ok := m.clearedFields[menu.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *MenuMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, menu.FieldType)
}

// SetMethod sets the "method" field.
func (m *MenuMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *MenuMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ClearMethod clears the value of the "method" field.
func (m *MenuMutation) ClearMethod() {
	m.method = nil
	m.clearedFields[menu.FieldMethod] = struct{}{}
}

// MethodCleared returns if the "method" field was cleared in this mutation.
func (m *MenuMutation) MethodCleared() bool {
	_, ok := m.clearedFields[menu.FieldMethod]
	return ok
}

// ResetMethod resets all changes to the "method" field.
func (m *MenuMutation) ResetMethod() {
	m.method = nil
	delete(m.clearedFields, menu.FieldMethod)
}

// SetVisible sets the "visible" field.
func (m *MenuMutation) SetVisible(b bool) {
	m.visible = &b
}

// Visible returns the value of the "visible" field in the mutation.
func (m *MenuMutation) Visible() (r bool, exists bool) {
	v := m.visible
	if v == nil {
		return
	}
	return *v, true
}

// OldVisible returns the old "visible" field's value of the Menu entity.
// If the Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MenuMutation) OldVisible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisible: %w", err)
	}
	return oldValue.Visible, nil
}

// ClearVisible clears the value of the "visible" field.
func (m *MenuMutation) ClearVisible() {
	m.visible = nil
	m.clearedFields[menu.FieldVisible] = struct{}{}
}

// VisibleCleared returns if the "visible" field was cleared in this mutation.
func (m *MenuMutation) VisibleCleared() bool {
	_, ok := m.clearedFields[menu.FieldVisible]
	return ok
}

// ResetVisible resets all changes to the "visible" field.
func (m *MenuMutation) ResetVisible() {
	m.visible = nil
	delete(m.clearedFields, menu.FieldVisible)
}

// ClearParent clears the "parent" edge to the Menu entity.
func (m *MenuMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[menu.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Menu entity was cleared.
func (m *MenuMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *MenuMutation) ParentIDs() (ids []string) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *MenuMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Menu entity by ids.
func (m *MenuMutation) AddChildIDs(ids ...string) {
	if m.children == nil {
		m.children = make(map[string]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Menu entity.
func (m *MenuMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Menu entity was cleared.
func (m *MenuMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Menu entity by IDs.
func (m *MenuMutation) RemoveChildIDs(ids ...string) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Menu entity.
func (m *MenuMutation) RemovedChildrenIDs() (ids []string) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *MenuMutation) ChildrenIDs() (ids []string) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *MenuMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddRoleIDs adds the "roles" edge to the Role_Menu entity by ids.
func (m *MenuMutation) AddRoleIDs(ids ...string) {
	if m.roles == nil {
		m.roles = make(map[string]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role_Menu entity.
func (m *MenuMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role_Menu entity was cleared.
func (m *MenuMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role_Menu entity by IDs.
func (m *MenuMutation) RemoveRoleIDs(ids ...string) {
	if m.removedroles == nil {
		m.removedroles = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role_Menu entity.
func (m *MenuMutation) RemovedRolesIDs() (ids []string) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *MenuMutation) RolesIDs() (ids []string) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *MenuMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// Where appends a list predicates to the MenuMutation builder.
func (m *MenuMutation) Where(ps ...predicate.Menu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MenuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MenuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Menu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MenuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MenuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Menu).
func (m *MenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MenuMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, menu.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, menu.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, menu.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, menu.FieldUpdatedBy)
	}
	if m.status != nil {
		fields = append(fields, menu.FieldStatus)
	}
	if m.sort != nil {
		fields = append(fields, menu.FieldSort)
	}
	if m.remark != nil {
		fields = append(fields, menu.FieldRemark)
	}
	if m.name != nil {
		fields = append(fields, menu.FieldName)
	}
	if m.parent != nil {
		fields = append(fields, menu.FieldParentID)
	}
	if m.icon != nil {
		fields = append(fields, menu.FieldIcon)
	}
	if m._path != nil {
		fields = append(fields, menu.FieldPath)
	}
	if m.permission != nil {
		fields = append(fields, menu.FieldPermission)
	}
	if m.component != nil {
		fields = append(fields, menu.FieldComponent)
	}
	if m._type != nil {
		fields = append(fields, menu.FieldType)
	}
	if m.method != nil {
		fields = append(fields, menu.FieldMethod)
	}
	if m.visible != nil {
		fields = append(fields, menu.FieldVisible)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldCreatedAt:
		return m.CreatedAt()
	case menu.FieldUpdatedAt:
		return m.UpdatedAt()
	case menu.FieldCreatedBy:
		return m.CreatedBy()
	case menu.FieldUpdatedBy:
		return m.UpdatedBy()
	case menu.FieldStatus:
		return m.Status()
	case menu.FieldSort:
		return m.Sort()
	case menu.FieldRemark:
		return m.Remark()
	case menu.FieldName:
		return m.Name()
	case menu.FieldParentID:
		return m.ParentID()
	case menu.FieldIcon:
		return m.Icon()
	case menu.FieldPath:
		return m.Path()
	case menu.FieldPermission:
		return m.Permission()
	case menu.FieldComponent:
		return m.Component()
	case menu.FieldType:
		return m.GetType()
	case menu.FieldMethod:
		return m.Method()
	case menu.FieldVisible:
		return m.Visible()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case menu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case menu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case menu.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case menu.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case menu.FieldStatus:
		return m.OldStatus(ctx)
	case menu.FieldSort:
		return m.OldSort(ctx)
	case menu.FieldRemark:
		return m.OldRemark(ctx)
	case menu.FieldName:
		return m.OldName(ctx)
	case menu.FieldParentID:
		return m.OldParentID(ctx)
	case menu.FieldIcon:
		return m.OldIcon(ctx)
	case menu.FieldPath:
		return m.OldPath(ctx)
	case menu.FieldPermission:
		return m.OldPermission(ctx)
	case menu.FieldComponent:
		return m.OldComponent(ctx)
	case menu.FieldType:
		return m.OldType(ctx)
	case menu.FieldMethod:
		return m.OldMethod(ctx)
	case menu.FieldVisible:
		return m.OldVisible(ctx)
	}
	return nil, fmt.Errorf("unknown Menu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case menu.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case menu.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case menu.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case menu.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case menu.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case menu.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case menu.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case menu.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case menu.FieldParentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case menu.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case menu.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case menu.FieldPermission:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermission(v)
		return nil
	case menu.FieldComponent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComponent(v)
		return nil
	case menu.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case menu.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case menu.FieldVisible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisible(v)
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MenuMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, menu.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, menu.FieldUpdatedAt)
	}
	if m.addsort != nil {
		fields = append(fields, menu.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MenuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case menu.FieldCreatedAt:
		return m.AddedCreatedAt()
	case menu.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case menu.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case menu.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case menu.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case menu.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown Menu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MenuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(menu.FieldCreatedBy) {
		fields = append(fields, menu.FieldCreatedBy)
	}
	if m.FieldCleared(menu.FieldUpdatedBy) {
		fields = append(fields, menu.FieldUpdatedBy)
	}
	if m.FieldCleared(menu.FieldStatus) {
		fields = append(fields, menu.FieldStatus)
	}
	if m.FieldCleared(menu.FieldSort) {
		fields = append(fields, menu.FieldSort)
	}
	if m.FieldCleared(menu.FieldRemark) {
		fields = append(fields, menu.FieldRemark)
	}
	if m.FieldCleared(menu.FieldParentID) {
		fields = append(fields, menu.FieldParentID)
	}
	if m.FieldCleared(menu.FieldIcon) {
		fields = append(fields, menu.FieldIcon)
	}
	if m.FieldCleared(menu.FieldPath) {
		fields = append(fields, menu.FieldPath)
	}
	if m.FieldCleared(menu.FieldPermission) {
		fields = append(fields, menu.FieldPermission)
	}
	if m.FieldCleared(menu.FieldComponent) {
		fields = append(fields, menu.FieldComponent)
	}
	if m.FieldCleared(menu.FieldType) {
		fields = append(fields, menu.FieldType)
	}
	if m.FieldCleared(menu.FieldMethod) {
		fields = append(fields, menu.FieldMethod)
	}
	if m.FieldCleared(menu.FieldVisible) {
		fields = append(fields, menu.FieldVisible)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MenuMutation) ClearField(name string) error {
	switch name {
	case menu.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case menu.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case menu.FieldStatus:
		m.ClearStatus()
		return nil
	case menu.FieldSort:
		m.ClearSort()
		return nil
	case menu.FieldRemark:
		m.ClearRemark()
		return nil
	case menu.FieldParentID:
		m.ClearParentID()
		return nil
	case menu.FieldIcon:
		m.ClearIcon()
		return nil
	case menu.FieldPath:
		m.ClearPath()
		return nil
	case menu.FieldPermission:
		m.ClearPermission()
		return nil
	case menu.FieldComponent:
		m.ClearComponent()
		return nil
	case menu.FieldType:
		m.ClearType()
		return nil
	case menu.FieldMethod:
		m.ClearMethod()
		return nil
	case menu.FieldVisible:
		m.ClearVisible()
		return nil
	}
	return fmt.Errorf("unknown Menu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MenuMutation) ResetField(name string) error {
	switch name {
	case menu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case menu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case menu.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case menu.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case menu.FieldStatus:
		m.ResetStatus()
		return nil
	case menu.FieldSort:
		m.ResetSort()
		return nil
	case menu.FieldRemark:
		m.ResetRemark()
		return nil
	case menu.FieldName:
		m.ResetName()
		return nil
	case menu.FieldParentID:
		m.ResetParentID()
		return nil
	case menu.FieldIcon:
		m.ResetIcon()
		return nil
	case menu.FieldPath:
		m.ResetPath()
		return nil
	case menu.FieldPermission:
		m.ResetPermission()
		return nil
	case menu.FieldComponent:
		m.ResetComponent()
		return nil
	case menu.FieldType:
		m.ResetType()
		return nil
	case menu.FieldMethod:
		m.ResetMethod()
		return nil
	case menu.FieldVisible:
		m.ResetVisible()
		return nil
	}
	return fmt.Errorf("unknown Menu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, menu.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, menu.EdgeChildren)
	}
	if m.roles != nil {
		edges = append(edges, menu.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MenuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case menu.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedchildren != nil {
		edges = append(edges, menu.EdgeChildren)
	}
	if m.removedroles != nil {
		edges = append(edges, menu.EdgeRoles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MenuMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case menu.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case menu.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, menu.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, menu.EdgeChildren)
	}
	if m.clearedroles {
		edges = append(edges, menu.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MenuMutation) EdgeCleared(name string) bool {
	switch name {
	case menu.EdgeParent:
		return m.clearedparent
	case menu.EdgeChildren:
		return m.clearedchildren
	case menu.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MenuMutation) ClearEdge(name string) error {
	switch name {
	case menu.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Menu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MenuMutation) ResetEdge(name string) error {
	switch name {
	case menu.EdgeParent:
		m.ResetParent()
		return nil
	case menu.EdgeChildren:
		m.ResetChildren()
		return nil
	case menu.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown Menu edge %s", name)
}

// OrganizationMutation represents an operation that mutates the Organization nodes in the graph.
type OrganizationMutation struct {
	config
	op              Op
	typ             string
	id              *string
	created_at      *int64
	addcreated_at   *int64
	updated_at      *int64
	addupdated_at   *int64
	created_by      *string
	updated_by      *string
	status          *string
	sort            *int32
	addsort         *int32
	remark          *string
	name            *string
	code            *string
	clearedFields   map[string]struct{}
	parent          *string
	clearedparent   bool
	children        map[string]struct{}
	removedchildren map[string]struct{}
	clearedchildren bool
	roles           map[string]struct{}
	removedroles    map[string]struct{}
	clearedroles    bool
	staffs          map[string]struct{}
	removedstaffs   map[string]struct{}
	clearedstaffs   bool
	done            bool
	oldValue        func(context.Context) (*Organization, error)
	predicates      []predicate.Organization
}

var _ ent.Mutation = (*OrganizationMutation)(nil)

// organizationOption allows management of the mutation configuration using functional options.
type organizationOption func(*OrganizationMutation)

// newOrganizationMutation creates new mutation for the Organization entity.
func newOrganizationMutation(c config, op Op, opts ...organizationOption) *OrganizationMutation {
	m := &OrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganizationID sets the ID field of the mutation.
func withOrganizationID(id string) organizationOption {
	return func(m *OrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Organization
		)
		m.oldValue = func(ctx context.Context) (*Organization, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrganization sets the old Organization of the mutation.
func withOrganization(node *Organization) organizationOption {
	return func(m *OrganizationMutation) {
		m.oldValue = func(context.Context) (*Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Organization entities.
func (m *OrganizationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrganizationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrganizationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Organization.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrganizationMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrganizationMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *OrganizationMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *OrganizationMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrganizationMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrganizationMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrganizationMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *OrganizationMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *OrganizationMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrganizationMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *OrganizationMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *OrganizationMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *OrganizationMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[organization.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *OrganizationMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[organization.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *OrganizationMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, organization.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *OrganizationMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *OrganizationMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *OrganizationMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[organization.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *OrganizationMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[organization.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *OrganizationMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, organization.FieldUpdatedBy)
}

// SetStatus sets the "status" field.
func (m *OrganizationMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *OrganizationMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *OrganizationMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[organization.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *OrganizationMutation) StatusCleared() bool {
	_, ok := m.clearedFields[organization.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *OrganizationMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, organization.FieldStatus)
}

// SetSort sets the "sort" field.
func (m *OrganizationMutation) SetSort(i int32) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *OrganizationMutation) Sort() (r int32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldSort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *OrganizationMutation) AddSort(i int32) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *OrganizationMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ClearSort clears the value of the "sort" field.
func (m *OrganizationMutation) ClearSort() {
	m.sort = nil
	m.addsort = nil
	m.clearedFields[organization.FieldSort] = struct{}{}
}

// SortCleared returns if the "sort" field was cleared in this mutation.
func (m *OrganizationMutation) SortCleared() bool {
	_, ok := m.clearedFields[organization.FieldSort]
	return ok
}

// ResetSort resets all changes to the "sort" field.
func (m *OrganizationMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
	delete(m.clearedFields, organization.FieldSort)
}

// SetRemark sets the "remark" field.
func (m *OrganizationMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *OrganizationMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *OrganizationMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[organization.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *OrganizationMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[organization.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *OrganizationMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, organization.FieldRemark)
}

// SetName sets the "name" field.
func (m *OrganizationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OrganizationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OrganizationMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *OrganizationMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *OrganizationMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *OrganizationMutation) ResetCode() {
	m.code = nil
}

// SetParentID sets the "parent_id" field.
func (m *OrganizationMutation) SetParentID(s string) {
	m.parent = &s
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *OrganizationMutation) ParentID() (r string, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Organization entity.
// If the Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrganizationMutation) OldParentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *OrganizationMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[organization.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *OrganizationMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[organization.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *OrganizationMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, organization.FieldParentID)
}

// ClearParent clears the "parent" edge to the Organization entity.
func (m *OrganizationMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[organization.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Organization entity was cleared.
func (m *OrganizationMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *OrganizationMutation) ParentIDs() (ids []string) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *OrganizationMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Organization entity by ids.
func (m *OrganizationMutation) AddChildIDs(ids ...string) {
	if m.children == nil {
		m.children = make(map[string]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Organization entity.
func (m *OrganizationMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Organization entity was cleared.
func (m *OrganizationMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Organization entity by IDs.
func (m *OrganizationMutation) RemoveChildIDs(ids ...string) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Organization entity.
func (m *OrganizationMutation) RemovedChildrenIDs() (ids []string) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *OrganizationMutation) ChildrenIDs() (ids []string) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *OrganizationMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddRoleIDs adds the "roles" edge to the Role_Organization entity by ids.
func (m *OrganizationMutation) AddRoleIDs(ids ...string) {
	if m.roles == nil {
		m.roles = make(map[string]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Role_Organization entity.
func (m *OrganizationMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Role_Organization entity was cleared.
func (m *OrganizationMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Role_Organization entity by IDs.
func (m *OrganizationMutation) RemoveRoleIDs(ids ...string) {
	if m.removedroles == nil {
		m.removedroles = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Role_Organization entity.
func (m *OrganizationMutation) RemovedRolesIDs() (ids []string) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *OrganizationMutation) RolesIDs() (ids []string) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *OrganizationMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddStaffIDs adds the "staffs" edge to the Staff entity by ids.
func (m *OrganizationMutation) AddStaffIDs(ids ...string) {
	if m.staffs == nil {
		m.staffs = make(map[string]struct{})
	}
	for i := range ids {
		m.staffs[ids[i]] = struct{}{}
	}
}

// ClearStaffs clears the "staffs" edge to the Staff entity.
func (m *OrganizationMutation) ClearStaffs() {
	m.clearedstaffs = true
}

// StaffsCleared reports if the "staffs" edge to the Staff entity was cleared.
func (m *OrganizationMutation) StaffsCleared() bool {
	return m.clearedstaffs
}

// RemoveStaffIDs removes the "staffs" edge to the Staff entity by IDs.
func (m *OrganizationMutation) RemoveStaffIDs(ids ...string) {
	if m.removedstaffs == nil {
		m.removedstaffs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.staffs, ids[i])
		m.removedstaffs[ids[i]] = struct{}{}
	}
}

// RemovedStaffs returns the removed IDs of the "staffs" edge to the Staff entity.
func (m *OrganizationMutation) RemovedStaffsIDs() (ids []string) {
	for id := range m.removedstaffs {
		ids = append(ids, id)
	}
	return
}

// StaffsIDs returns the "staffs" edge IDs in the mutation.
func (m *OrganizationMutation) StaffsIDs() (ids []string) {
	for id := range m.staffs {
		ids = append(ids, id)
	}
	return
}

// ResetStaffs resets all changes to the "staffs" edge.
func (m *OrganizationMutation) ResetStaffs() {
	m.staffs = nil
	m.clearedstaffs = false
	m.removedstaffs = nil
}

// Where appends a list predicates to the OrganizationMutation builder.
func (m *OrganizationMutation) Where(ps ...predicate.Organization) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrganizationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrganizationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Organization, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrganizationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrganizationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Organization).
func (m *OrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrganizationMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, organization.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, organization.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, organization.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, organization.FieldUpdatedBy)
	}
	if m.status != nil {
		fields = append(fields, organization.FieldStatus)
	}
	if m.sort != nil {
		fields = append(fields, organization.FieldSort)
	}
	if m.remark != nil {
		fields = append(fields, organization.FieldRemark)
	}
	if m.name != nil {
		fields = append(fields, organization.FieldName)
	}
	if m.code != nil {
		fields = append(fields, organization.FieldCode)
	}
	if m.parent != nil {
		fields = append(fields, organization.FieldParentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldCreatedAt:
		return m.CreatedAt()
	case organization.FieldUpdatedAt:
		return m.UpdatedAt()
	case organization.FieldCreatedBy:
		return m.CreatedBy()
	case organization.FieldUpdatedBy:
		return m.UpdatedBy()
	case organization.FieldStatus:
		return m.Status()
	case organization.FieldSort:
		return m.Sort()
	case organization.FieldRemark:
		return m.Remark()
	case organization.FieldName:
		return m.Name()
	case organization.FieldCode:
		return m.Code()
	case organization.FieldParentID:
		return m.ParentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organization.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case organization.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case organization.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case organization.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case organization.FieldStatus:
		return m.OldStatus(ctx)
	case organization.FieldSort:
		return m.OldSort(ctx)
	case organization.FieldRemark:
		return m.OldRemark(ctx)
	case organization.FieldName:
		return m.OldName(ctx)
	case organization.FieldCode:
		return m.OldCode(ctx)
	case organization.FieldParentID:
		return m.OldParentID(ctx)
	}
	return nil, fmt.Errorf("unknown Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organization.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case organization.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case organization.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case organization.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case organization.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case organization.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case organization.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case organization.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case organization.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case organization.FieldParentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrganizationMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, organization.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, organization.FieldUpdatedAt)
	}
	if m.addsort != nil {
		fields = append(fields, organization.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrganizationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case organization.FieldCreatedAt:
		return m.AddedCreatedAt()
	case organization.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case organization.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case organization.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case organization.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case organization.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrganizationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(organization.FieldCreatedBy) {
		fields = append(fields, organization.FieldCreatedBy)
	}
	if m.FieldCleared(organization.FieldUpdatedBy) {
		fields = append(fields, organization.FieldUpdatedBy)
	}
	if m.FieldCleared(organization.FieldStatus) {
		fields = append(fields, organization.FieldStatus)
	}
	if m.FieldCleared(organization.FieldSort) {
		fields = append(fields, organization.FieldSort)
	}
	if m.FieldCleared(organization.FieldRemark) {
		fields = append(fields, organization.FieldRemark)
	}
	if m.FieldCleared(organization.FieldParentID) {
		fields = append(fields, organization.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganizationMutation) ClearField(name string) error {
	switch name {
	case organization.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case organization.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case organization.FieldStatus:
		m.ClearStatus()
		return nil
	case organization.FieldSort:
		m.ClearSort()
		return nil
	case organization.FieldRemark:
		m.ClearRemark()
		return nil
	case organization.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrganizationMutation) ResetField(name string) error {
	switch name {
	case organization.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case organization.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case organization.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case organization.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case organization.FieldStatus:
		m.ResetStatus()
		return nil
	case organization.FieldSort:
		m.ResetSort()
		return nil
	case organization.FieldRemark:
		m.ResetRemark()
		return nil
	case organization.FieldName:
		m.ResetName()
		return nil
	case organization.FieldCode:
		m.ResetCode()
		return nil
	case organization.FieldParentID:
		m.ResetParentID()
		return nil
	}
	return fmt.Errorf("unknown Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.parent != nil {
		edges = append(edges, organization.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, organization.EdgeChildren)
	}
	if m.roles != nil {
		edges = append(edges, organization.EdgeRoles)
	}
	if m.staffs != nil {
		edges = append(edges, organization.EdgeStaffs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case organization.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeStaffs:
		ids := make([]ent.Value, 0, len(m.staffs))
		for id := range m.staffs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, organization.EdgeChildren)
	}
	if m.removedroles != nil {
		edges = append(edges, organization.EdgeRoles)
	}
	if m.removedstaffs != nil {
		edges = append(edges, organization.EdgeStaffs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrganizationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organization.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case organization.EdgeStaffs:
		ids := make([]ent.Value, 0, len(m.removedstaffs))
		for id := range m.removedstaffs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedparent {
		edges = append(edges, organization.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, organization.EdgeChildren)
	}
	if m.clearedroles {
		edges = append(edges, organization.EdgeRoles)
	}
	if m.clearedstaffs {
		edges = append(edges, organization.EdgeStaffs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case organization.EdgeParent:
		return m.clearedparent
	case organization.EdgeChildren:
		return m.clearedchildren
	case organization.EdgeRoles:
		return m.clearedroles
	case organization.EdgeStaffs:
		return m.clearedstaffs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrganizationMutation) ClearEdge(name string) error {
	switch name {
	case organization.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrganizationMutation) ResetEdge(name string) error {
	switch name {
	case organization.EdgeParent:
		m.ResetParent()
		return nil
	case organization.EdgeChildren:
		m.ResetChildren()
		return nil
	case organization.EdgeRoles:
		m.ResetRoles()
		return nil
	case organization.EdgeStaffs:
		m.ResetStaffs()
		return nil
	}
	return fmt.Errorf("unknown Organization edge %s", name)
}

// PositionMutation represents an operation that mutates the Position nodes in the graph.
type PositionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *int64
	addcreated_at *int64
	updated_at    *int64
	addupdated_at *int64
	created_by    *string
	updated_by    *string
	status        *string
	sort          *int32
	addsort       *int32
	remark        *string
	name          *string
	code          *string
	clearedFields map[string]struct{}
	staffs        map[string]struct{}
	removedstaffs map[string]struct{}
	clearedstaffs bool
	done          bool
	oldValue      func(context.Context) (*Position, error)
	predicates    []predicate.Position
}

var _ ent.Mutation = (*PositionMutation)(nil)

// positionOption allows management of the mutation configuration using functional options.
type positionOption func(*PositionMutation)

// newPositionMutation creates new mutation for the Position entity.
func newPositionMutation(c config, op Op, opts ...positionOption) *PositionMutation {
	m := &PositionMutation{
		config:        c,
		op:            op,
		typ:           TypePosition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPositionID sets the ID field of the mutation.
func withPositionID(id string) positionOption {
	return func(m *PositionMutation) {
		var (
			err   error
			once  sync.Once
			value *Position
		)
		m.oldValue = func(ctx context.Context) (*Position, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Position.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPosition sets the old Position of the mutation.
func withPosition(node *Position) positionOption {
	return func(m *PositionMutation) {
		m.oldValue = func(context.Context) (*Position, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PositionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PositionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Position entities.
func (m *PositionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PositionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PositionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Position.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PositionMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PositionMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *PositionMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *PositionMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PositionMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PositionMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PositionMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *PositionMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *PositionMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PositionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *PositionMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *PositionMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *PositionMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[position.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *PositionMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[position.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *PositionMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, position.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *PositionMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *PositionMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *PositionMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[position.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *PositionMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[position.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *PositionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, position.FieldUpdatedBy)
}

// SetStatus sets the "status" field.
func (m *PositionMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *PositionMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *PositionMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[position.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *PositionMutation) StatusCleared() bool {
	_, ok := m.clearedFields[position.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *PositionMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, position.FieldStatus)
}

// SetSort sets the "sort" field.
func (m *PositionMutation) SetSort(i int32) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *PositionMutation) Sort() (r int32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldSort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *PositionMutation) AddSort(i int32) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *PositionMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ClearSort clears the value of the "sort" field.
func (m *PositionMutation) ClearSort() {
	m.sort = nil
	m.addsort = nil
	m.clearedFields[position.FieldSort] = struct{}{}
}

// SortCleared returns if the "sort" field was cleared in this mutation.
func (m *PositionMutation) SortCleared() bool {
	_, ok := m.clearedFields[position.FieldSort]
	return ok
}

// ResetSort resets all changes to the "sort" field.
func (m *PositionMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
	delete(m.clearedFields, position.FieldSort)
}

// SetRemark sets the "remark" field.
func (m *PositionMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *PositionMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *PositionMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[position.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *PositionMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[position.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *PositionMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, position.FieldRemark)
}

// SetName sets the "name" field.
func (m *PositionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PositionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PositionMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *PositionMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *PositionMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *PositionMutation) ResetCode() {
	m.code = nil
}

// AddStaffIDs adds the "staffs" edge to the Staff_Position entity by ids.
func (m *PositionMutation) AddStaffIDs(ids ...string) {
	if m.staffs == nil {
		m.staffs = make(map[string]struct{})
	}
	for i := range ids {
		m.staffs[ids[i]] = struct{}{}
	}
}

// ClearStaffs clears the "staffs" edge to the Staff_Position entity.
func (m *PositionMutation) ClearStaffs() {
	m.clearedstaffs = true
}

// StaffsCleared reports if the "staffs" edge to the Staff_Position entity was cleared.
func (m *PositionMutation) StaffsCleared() bool {
	return m.clearedstaffs
}

// RemoveStaffIDs removes the "staffs" edge to the Staff_Position entity by IDs.
func (m *PositionMutation) RemoveStaffIDs(ids ...string) {
	if m.removedstaffs == nil {
		m.removedstaffs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.staffs, ids[i])
		m.removedstaffs[ids[i]] = struct{}{}
	}
}

// RemovedStaffs returns the removed IDs of the "staffs" edge to the Staff_Position entity.
func (m *PositionMutation) RemovedStaffsIDs() (ids []string) {
	for id := range m.removedstaffs {
		ids = append(ids, id)
	}
	return
}

// StaffsIDs returns the "staffs" edge IDs in the mutation.
func (m *PositionMutation) StaffsIDs() (ids []string) {
	for id := range m.staffs {
		ids = append(ids, id)
	}
	return
}

// ResetStaffs resets all changes to the "staffs" edge.
func (m *PositionMutation) ResetStaffs() {
	m.staffs = nil
	m.clearedstaffs = false
	m.removedstaffs = nil
}

// Where appends a list predicates to the PositionMutation builder.
func (m *PositionMutation) Where(ps ...predicate.Position) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PositionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PositionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Position, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PositionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PositionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Position).
func (m *PositionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PositionMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, position.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, position.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, position.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, position.FieldUpdatedBy)
	}
	if m.status != nil {
		fields = append(fields, position.FieldStatus)
	}
	if m.sort != nil {
		fields = append(fields, position.FieldSort)
	}
	if m.remark != nil {
		fields = append(fields, position.FieldRemark)
	}
	if m.name != nil {
		fields = append(fields, position.FieldName)
	}
	if m.code != nil {
		fields = append(fields, position.FieldCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PositionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case position.FieldCreatedAt:
		return m.CreatedAt()
	case position.FieldUpdatedAt:
		return m.UpdatedAt()
	case position.FieldCreatedBy:
		return m.CreatedBy()
	case position.FieldUpdatedBy:
		return m.UpdatedBy()
	case position.FieldStatus:
		return m.Status()
	case position.FieldSort:
		return m.Sort()
	case position.FieldRemark:
		return m.Remark()
	case position.FieldName:
		return m.Name()
	case position.FieldCode:
		return m.Code()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PositionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case position.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case position.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case position.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case position.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case position.FieldStatus:
		return m.OldStatus(ctx)
	case position.FieldSort:
		return m.OldSort(ctx)
	case position.FieldRemark:
		return m.OldRemark(ctx)
	case position.FieldName:
		return m.OldName(ctx)
	case position.FieldCode:
		return m.OldCode(ctx)
	}
	return nil, fmt.Errorf("unknown Position field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PositionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case position.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case position.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case position.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case position.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case position.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case position.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case position.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case position.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case position.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	}
	return fmt.Errorf("unknown Position field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PositionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, position.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, position.FieldUpdatedAt)
	}
	if m.addsort != nil {
		fields = append(fields, position.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PositionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case position.FieldCreatedAt:
		return m.AddedCreatedAt()
	case position.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case position.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PositionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case position.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case position.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case position.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown Position numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PositionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(position.FieldCreatedBy) {
		fields = append(fields, position.FieldCreatedBy)
	}
	if m.FieldCleared(position.FieldUpdatedBy) {
		fields = append(fields, position.FieldUpdatedBy)
	}
	if m.FieldCleared(position.FieldStatus) {
		fields = append(fields, position.FieldStatus)
	}
	if m.FieldCleared(position.FieldSort) {
		fields = append(fields, position.FieldSort)
	}
	if m.FieldCleared(position.FieldRemark) {
		fields = append(fields, position.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PositionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PositionMutation) ClearField(name string) error {
	switch name {
	case position.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case position.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case position.FieldStatus:
		m.ClearStatus()
		return nil
	case position.FieldSort:
		m.ClearSort()
		return nil
	case position.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Position nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PositionMutation) ResetField(name string) error {
	switch name {
	case position.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case position.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case position.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case position.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case position.FieldStatus:
		m.ResetStatus()
		return nil
	case position.FieldSort:
		m.ResetSort()
		return nil
	case position.FieldRemark:
		m.ResetRemark()
		return nil
	case position.FieldName:
		m.ResetName()
		return nil
	case position.FieldCode:
		m.ResetCode()
		return nil
	}
	return fmt.Errorf("unknown Position field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PositionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.staffs != nil {
		edges = append(edges, position.EdgeStaffs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PositionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case position.EdgeStaffs:
		ids := make([]ent.Value, 0, len(m.staffs))
		for id := range m.staffs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PositionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedstaffs != nil {
		edges = append(edges, position.EdgeStaffs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PositionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case position.EdgeStaffs:
		ids := make([]ent.Value, 0, len(m.removedstaffs))
		for id := range m.removedstaffs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PositionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstaffs {
		edges = append(edges, position.EdgeStaffs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PositionMutation) EdgeCleared(name string) bool {
	switch name {
	case position.EdgeStaffs:
		return m.clearedstaffs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PositionMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Position unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PositionMutation) ResetEdge(name string) error {
	switch name {
	case position.EdgeStaffs:
		m.ResetStaffs()
		return nil
	}
	return fmt.Errorf("unknown Position edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	created_at           *int64
	addcreated_at        *int64
	updated_at           *int64
	addupdated_at        *int64
	created_by           *string
	updated_by           *string
	status               *string
	sort                 *int32
	addsort              *int32
	remark               *string
	name                 *string
	code                 *string
	clearedFields        map[string]struct{}
	menus                map[string]struct{}
	removedmenus         map[string]struct{}
	clearedmenus         bool
	organizations        map[string]struct{}
	removedorganizations map[string]struct{}
	clearedorganizations bool
	staffs               map[string]struct{}
	removedstaffs        map[string]struct{}
	clearedstaffs        bool
	done                 bool
	oldValue             func(context.Context) (*Role, error)
	predicates           []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id string) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role entities.
func (m *RoleMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *RoleMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *RoleMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *RoleMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *RoleMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *RoleMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RoleMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *RoleMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[role.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *RoleMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[role.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RoleMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, role.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RoleMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RoleMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *RoleMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[role.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *RoleMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[role.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RoleMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, role.FieldUpdatedBy)
}

// SetStatus sets the "status" field.
func (m *RoleMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *RoleMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *RoleMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[role.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *RoleMutation) StatusCleared() bool {
	_, ok := m.clearedFields[role.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *RoleMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, role.FieldStatus)
}

// SetSort sets the "sort" field.
func (m *RoleMutation) SetSort(i int32) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *RoleMutation) Sort() (r int32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldSort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *RoleMutation) AddSort(i int32) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *RoleMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ClearSort clears the value of the "sort" field.
func (m *RoleMutation) ClearSort() {
	m.sort = nil
	m.addsort = nil
	m.clearedFields[role.FieldSort] = struct{}{}
}

// SortCleared returns if the "sort" field was cleared in this mutation.
func (m *RoleMutation) SortCleared() bool {
	_, ok := m.clearedFields[role.FieldSort]
	return ok
}

// ResetSort resets all changes to the "sort" field.
func (m *RoleMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
	delete(m.clearedFields, role.FieldSort)
}

// SetRemark sets the "remark" field.
func (m *RoleMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *RoleMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *RoleMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[role.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *RoleMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[role.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *RoleMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, role.FieldRemark)
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *RoleMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *RoleMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *RoleMutation) ResetCode() {
	m.code = nil
}

// AddMenuIDs adds the "menus" edge to the Role_Menu entity by ids.
func (m *RoleMutation) AddMenuIDs(ids ...string) {
	if m.menus == nil {
		m.menus = make(map[string]struct{})
	}
	for i := range ids {
		m.menus[ids[i]] = struct{}{}
	}
}

// ClearMenus clears the "menus" edge to the Role_Menu entity.
func (m *RoleMutation) ClearMenus() {
	m.clearedmenus = true
}

// MenusCleared reports if the "menus" edge to the Role_Menu entity was cleared.
func (m *RoleMutation) MenusCleared() bool {
	return m.clearedmenus
}

// RemoveMenuIDs removes the "menus" edge to the Role_Menu entity by IDs.
func (m *RoleMutation) RemoveMenuIDs(ids ...string) {
	if m.removedmenus == nil {
		m.removedmenus = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.menus, ids[i])
		m.removedmenus[ids[i]] = struct{}{}
	}
}

// RemovedMenus returns the removed IDs of the "menus" edge to the Role_Menu entity.
func (m *RoleMutation) RemovedMenusIDs() (ids []string) {
	for id := range m.removedmenus {
		ids = append(ids, id)
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
func (m *RoleMutation) MenusIDs() (ids []string) {
	for id := range m.menus {
		ids = append(ids, id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *RoleMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
	m.removedmenus = nil
}

// AddOrganizationIDs adds the "organizations" edge to the Role_Organization entity by ids.
func (m *RoleMutation) AddOrganizationIDs(ids ...string) {
	if m.organizations == nil {
		m.organizations = make(map[string]struct{})
	}
	for i := range ids {
		m.organizations[ids[i]] = struct{}{}
	}
}

// ClearOrganizations clears the "organizations" edge to the Role_Organization entity.
func (m *RoleMutation) ClearOrganizations() {
	m.clearedorganizations = true
}

// OrganizationsCleared reports if the "organizations" edge to the Role_Organization entity was cleared.
func (m *RoleMutation) OrganizationsCleared() bool {
	return m.clearedorganizations
}

// RemoveOrganizationIDs removes the "organizations" edge to the Role_Organization entity by IDs.
func (m *RoleMutation) RemoveOrganizationIDs(ids ...string) {
	if m.removedorganizations == nil {
		m.removedorganizations = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.organizations, ids[i])
		m.removedorganizations[ids[i]] = struct{}{}
	}
}

// RemovedOrganizations returns the removed IDs of the "organizations" edge to the Role_Organization entity.
func (m *RoleMutation) RemovedOrganizationsIDs() (ids []string) {
	for id := range m.removedorganizations {
		ids = append(ids, id)
	}
	return
}

// OrganizationsIDs returns the "organizations" edge IDs in the mutation.
func (m *RoleMutation) OrganizationsIDs() (ids []string) {
	for id := range m.organizations {
		ids = append(ids, id)
	}
	return
}

// ResetOrganizations resets all changes to the "organizations" edge.
func (m *RoleMutation) ResetOrganizations() {
	m.organizations = nil
	m.clearedorganizations = false
	m.removedorganizations = nil
}

// AddStaffIDs adds the "staffs" edge to the Staff_Role entity by ids.
func (m *RoleMutation) AddStaffIDs(ids ...string) {
	if m.staffs == nil {
		m.staffs = make(map[string]struct{})
	}
	for i := range ids {
		m.staffs[ids[i]] = struct{}{}
	}
}

// ClearStaffs clears the "staffs" edge to the Staff_Role entity.
func (m *RoleMutation) ClearStaffs() {
	m.clearedstaffs = true
}

// StaffsCleared reports if the "staffs" edge to the Staff_Role entity was cleared.
func (m *RoleMutation) StaffsCleared() bool {
	return m.clearedstaffs
}

// RemoveStaffIDs removes the "staffs" edge to the Staff_Role entity by IDs.
func (m *RoleMutation) RemoveStaffIDs(ids ...string) {
	if m.removedstaffs == nil {
		m.removedstaffs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.staffs, ids[i])
		m.removedstaffs[ids[i]] = struct{}{}
	}
}

// RemovedStaffs returns the removed IDs of the "staffs" edge to the Staff_Role entity.
func (m *RoleMutation) RemovedStaffsIDs() (ids []string) {
	for id := range m.removedstaffs {
		ids = append(ids, id)
	}
	return
}

// StaffsIDs returns the "staffs" edge IDs in the mutation.
func (m *RoleMutation) StaffsIDs() (ids []string) {
	for id := range m.staffs {
		ids = append(ids, id)
	}
	return
}

// ResetStaffs resets all changes to the "staffs" edge.
func (m *RoleMutation) ResetStaffs() {
	m.staffs = nil
	m.clearedstaffs = false
	m.removedstaffs = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, role.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, role.FieldUpdatedBy)
	}
	if m.status != nil {
		fields = append(fields, role.FieldStatus)
	}
	if m.sort != nil {
		fields = append(fields, role.FieldSort)
	}
	if m.remark != nil {
		fields = append(fields, role.FieldRemark)
	}
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.code != nil {
		fields = append(fields, role.FieldCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.CreatedAt()
	case role.FieldUpdatedAt:
		return m.UpdatedAt()
	case role.FieldCreatedBy:
		return m.CreatedBy()
	case role.FieldUpdatedBy:
		return m.UpdatedBy()
	case role.FieldStatus:
		return m.Status()
	case role.FieldSort:
		return m.Sort()
	case role.FieldRemark:
		return m.Remark()
	case role.FieldName:
		return m.Name()
	case role.FieldCode:
		return m.Code()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case role.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case role.FieldStatus:
		return m.OldStatus(ctx)
	case role.FieldSort:
		return m.OldSort(ctx)
	case role.FieldRemark:
		return m.OldRemark(ctx)
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldCode:
		return m.OldCode(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case role.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case role.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case role.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case role.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, role.FieldUpdatedAt)
	}
	if m.addsort != nil {
		fields = append(fields, role.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role.FieldCreatedAt:
		return m.AddedCreatedAt()
	case role.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case role.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case role.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case role.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldCreatedBy) {
		fields = append(fields, role.FieldCreatedBy)
	}
	if m.FieldCleared(role.FieldUpdatedBy) {
		fields = append(fields, role.FieldUpdatedBy)
	}
	if m.FieldCleared(role.FieldStatus) {
		fields = append(fields, role.FieldStatus)
	}
	if m.FieldCleared(role.FieldSort) {
		fields = append(fields, role.FieldSort)
	}
	if m.FieldCleared(role.FieldRemark) {
		fields = append(fields, role.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case role.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case role.FieldStatus:
		m.ClearStatus()
		return nil
	case role.FieldSort:
		m.ClearSort()
		return nil
	case role.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case role.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case role.FieldStatus:
		m.ResetStatus()
		return nil
	case role.FieldSort:
		m.ResetSort()
		return nil
	case role.FieldRemark:
		m.ResetRemark()
		return nil
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldCode:
		m.ResetCode()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.menus != nil {
		edges = append(edges, role.EdgeMenus)
	}
	if m.organizations != nil {
		edges = append(edges, role.EdgeOrganizations)
	}
	if m.staffs != nil {
		edges = append(edges, role.EdgeStaffs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.menus))
		for id := range m.menus {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.organizations))
		for id := range m.organizations {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeStaffs:
		ids := make([]ent.Value, 0, len(m.staffs))
		for id := range m.staffs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmenus != nil {
		edges = append(edges, role.EdgeMenus)
	}
	if m.removedorganizations != nil {
		edges = append(edges, role.EdgeOrganizations)
	}
	if m.removedstaffs != nil {
		edges = append(edges, role.EdgeStaffs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeMenus:
		ids := make([]ent.Value, 0, len(m.removedmenus))
		for id := range m.removedmenus {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeOrganizations:
		ids := make([]ent.Value, 0, len(m.removedorganizations))
		for id := range m.removedorganizations {
			ids = append(ids, id)
		}
		return ids
	case role.EdgeStaffs:
		ids := make([]ent.Value, 0, len(m.removedstaffs))
		for id := range m.removedstaffs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmenus {
		edges = append(edges, role.EdgeMenus)
	}
	if m.clearedorganizations {
		edges = append(edges, role.EdgeOrganizations)
	}
	if m.clearedstaffs {
		edges = append(edges, role.EdgeStaffs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeMenus:
		return m.clearedmenus
	case role.EdgeOrganizations:
		return m.clearedorganizations
	case role.EdgeStaffs:
		return m.clearedstaffs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeMenus:
		m.ResetMenus()
		return nil
	case role.EdgeOrganizations:
		m.ResetOrganizations()
		return nil
	case role.EdgeStaffs:
		m.ResetStaffs()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// RoleMenuMutation represents an operation that mutates the Role_Menu nodes in the graph.
type RoleMenuMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *int64
	addcreated_at *int64
	updated_at    *int64
	addupdated_at *int64
	created_by    *string
	updated_by    *string
	clearedFields map[string]struct{}
	roles         *string
	clearedroles  bool
	menus         *string
	clearedmenus  bool
	done          bool
	oldValue      func(context.Context) (*Role_Menu, error)
	predicates    []predicate.Role_Menu
}

var _ ent.Mutation = (*RoleMenuMutation)(nil)

// roleMenuOption allows management of the mutation configuration using functional options.
type roleMenuOption func(*RoleMenuMutation)

// newRoleMenuMutation creates new mutation for the Role_Menu entity.
func newRoleMenuMutation(c config, op Op, opts ...roleMenuOption) *RoleMenuMutation {
	m := &RoleMenuMutation{
		config:        c,
		op:            op,
		typ:           TypeRoleMenu,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRole_MenuID sets the ID field of the mutation.
func withRole_MenuID(id string) roleMenuOption {
	return func(m *RoleMenuMutation) {
		var (
			err   error
			once  sync.Once
			value *Role_Menu
		)
		m.oldValue = func(ctx context.Context) (*Role_Menu, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role_Menu.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole_Menu sets the old Role_Menu of the mutation.
func withRole_Menu(node *Role_Menu) roleMenuOption {
	return func(m *RoleMenuMutation) {
		m.oldValue = func(context.Context) (*Role_Menu, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMenuMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMenuMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role_Menu entities.
func (m *RoleMenuMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMenuMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMenuMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role_Menu.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMenuMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMenuMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role_Menu entity.
// If the Role_Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMenuMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *RoleMenuMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *RoleMenuMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMenuMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleMenuMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleMenuMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role_Menu entity.
// If the Role_Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMenuMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *RoleMenuMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *RoleMenuMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleMenuMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *RoleMenuMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RoleMenuMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Role_Menu entity.
// If the Role_Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMenuMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *RoleMenuMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[role_menu.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *RoleMenuMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[role_menu.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RoleMenuMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, role_menu.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RoleMenuMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RoleMenuMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Role_Menu entity.
// If the Role_Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMenuMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *RoleMenuMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[role_menu.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *RoleMenuMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[role_menu.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RoleMenuMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, role_menu.FieldUpdatedBy)
}

// SetRoleID sets the "role_id" field.
func (m *RoleMenuMutation) SetRoleID(s string) {
	m.roles = &s
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *RoleMenuMutation) RoleID() (r string, exists bool) {
	v := m.roles
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the Role_Menu entity.
// If the Role_Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMenuMutation) OldRoleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *RoleMenuMutation) ResetRoleID() {
	m.roles = nil
}

// SetMenuID sets the "menu_id" field.
func (m *RoleMenuMutation) SetMenuID(s string) {
	m.menus = &s
}

// MenuID returns the value of the "menu_id" field in the mutation.
func (m *RoleMenuMutation) MenuID() (r string, exists bool) {
	v := m.menus
	if v == nil {
		return
	}
	return *v, true
}

// OldMenuID returns the old "menu_id" field's value of the Role_Menu entity.
// If the Role_Menu object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMenuMutation) OldMenuID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMenuID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMenuID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMenuID: %w", err)
	}
	return oldValue.MenuID, nil
}

// ResetMenuID resets all changes to the "menu_id" field.
func (m *RoleMenuMutation) ResetMenuID() {
	m.menus = nil
}

// SetRolesID sets the "roles" edge to the Role entity by id.
func (m *RoleMenuMutation) SetRolesID(id string) {
	m.roles = &id
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *RoleMenuMutation) ClearRoles() {
	m.clearedroles = true
	m.clearedFields[role_menu.FieldRoleID] = struct{}{}
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *RoleMenuMutation) RolesCleared() bool {
	return m.clearedroles
}

// RolesID returns the "roles" edge ID in the mutation.
func (m *RoleMenuMutation) RolesID() (id string, exists bool) {
	if m.roles != nil {
		return *m.roles, true
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RolesID instead. It exists only for internal usage by the builders.
func (m *RoleMenuMutation) RolesIDs() (ids []string) {
	if id := m.roles; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *RoleMenuMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
}

// SetMenusID sets the "menus" edge to the Menu entity by id.
func (m *RoleMenuMutation) SetMenusID(id string) {
	m.menus = &id
}

// ClearMenus clears the "menus" edge to the Menu entity.
func (m *RoleMenuMutation) ClearMenus() {
	m.clearedmenus = true
	m.clearedFields[role_menu.FieldMenuID] = struct{}{}
}

// MenusCleared reports if the "menus" edge to the Menu entity was cleared.
func (m *RoleMenuMutation) MenusCleared() bool {
	return m.clearedmenus
}

// MenusID returns the "menus" edge ID in the mutation.
func (m *RoleMenuMutation) MenusID() (id string, exists bool) {
	if m.menus != nil {
		return *m.menus, true
	}
	return
}

// MenusIDs returns the "menus" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MenusID instead. It exists only for internal usage by the builders.
func (m *RoleMenuMutation) MenusIDs() (ids []string) {
	if id := m.menus; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMenus resets all changes to the "menus" edge.
func (m *RoleMenuMutation) ResetMenus() {
	m.menus = nil
	m.clearedmenus = false
}

// Where appends a list predicates to the RoleMenuMutation builder.
func (m *RoleMenuMutation) Where(ps ...predicate.Role_Menu) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMenuMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMenuMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role_Menu, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMenuMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMenuMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role_Menu).
func (m *RoleMenuMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMenuMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, role_menu.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role_menu.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, role_menu.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, role_menu.FieldUpdatedBy)
	}
	if m.roles != nil {
		fields = append(fields, role_menu.FieldRoleID)
	}
	if m.menus != nil {
		fields = append(fields, role_menu.FieldMenuID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMenuMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role_menu.FieldCreatedAt:
		return m.CreatedAt()
	case role_menu.FieldUpdatedAt:
		return m.UpdatedAt()
	case role_menu.FieldCreatedBy:
		return m.CreatedBy()
	case role_menu.FieldUpdatedBy:
		return m.UpdatedBy()
	case role_menu.FieldRoleID:
		return m.RoleID()
	case role_menu.FieldMenuID:
		return m.MenuID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMenuMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role_menu.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role_menu.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role_menu.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case role_menu.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case role_menu.FieldRoleID:
		return m.OldRoleID(ctx)
	case role_menu.FieldMenuID:
		return m.OldMenuID(ctx)
	}
	return nil, fmt.Errorf("unknown Role_Menu field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMenuMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role_menu.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role_menu.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role_menu.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case role_menu.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case role_menu.FieldRoleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case role_menu.FieldMenuID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMenuID(v)
		return nil
	}
	return fmt.Errorf("unknown Role_Menu field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMenuMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, role_menu.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, role_menu.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMenuMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role_menu.FieldCreatedAt:
		return m.AddedCreatedAt()
	case role_menu.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMenuMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role_menu.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case role_menu.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Role_Menu numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMenuMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role_menu.FieldCreatedBy) {
		fields = append(fields, role_menu.FieldCreatedBy)
	}
	if m.FieldCleared(role_menu.FieldUpdatedBy) {
		fields = append(fields, role_menu.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMenuMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMenuMutation) ClearField(name string) error {
	switch name {
	case role_menu.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case role_menu.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Role_Menu nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMenuMutation) ResetField(name string) error {
	switch name {
	case role_menu.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role_menu.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role_menu.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case role_menu.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case role_menu.FieldRoleID:
		m.ResetRoleID()
		return nil
	case role_menu.FieldMenuID:
		m.ResetMenuID()
		return nil
	}
	return fmt.Errorf("unknown Role_Menu field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMenuMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.roles != nil {
		edges = append(edges, role_menu.EdgeRoles)
	}
	if m.menus != nil {
		edges = append(edges, role_menu.EdgeMenus)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMenuMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role_menu.EdgeRoles:
		if id := m.roles; id != nil {
			return []ent.Value{*id}
		}
	case role_menu.EdgeMenus:
		if id := m.menus; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMenuMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMenuMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMenuMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedroles {
		edges = append(edges, role_menu.EdgeRoles)
	}
	if m.clearedmenus {
		edges = append(edges, role_menu.EdgeMenus)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMenuMutation) EdgeCleared(name string) bool {
	switch name {
	case role_menu.EdgeRoles:
		return m.clearedroles
	case role_menu.EdgeMenus:
		return m.clearedmenus
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMenuMutation) ClearEdge(name string) error {
	switch name {
	case role_menu.EdgeRoles:
		m.ClearRoles()
		return nil
	case role_menu.EdgeMenus:
		m.ClearMenus()
		return nil
	}
	return fmt.Errorf("unknown Role_Menu unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMenuMutation) ResetEdge(name string) error {
	switch name {
	case role_menu.EdgeRoles:
		m.ResetRoles()
		return nil
	case role_menu.EdgeMenus:
		m.ResetMenus()
		return nil
	}
	return fmt.Errorf("unknown Role_Menu edge %s", name)
}

// RoleOrganizationMutation represents an operation that mutates the Role_Organization nodes in the graph.
type RoleOrganizationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	created_at           *int64
	addcreated_at        *int64
	updated_at           *int64
	addupdated_at        *int64
	created_by           *string
	updated_by           *string
	clearedFields        map[string]struct{}
	roles                *string
	clearedroles         bool
	organizations        *string
	clearedorganizations bool
	done                 bool
	oldValue             func(context.Context) (*Role_Organization, error)
	predicates           []predicate.Role_Organization
}

var _ ent.Mutation = (*RoleOrganizationMutation)(nil)

// roleOrganizationOption allows management of the mutation configuration using functional options.
type roleOrganizationOption func(*RoleOrganizationMutation)

// newRoleOrganizationMutation creates new mutation for the Role_Organization entity.
func newRoleOrganizationMutation(c config, op Op, opts ...roleOrganizationOption) *RoleOrganizationMutation {
	m := &RoleOrganizationMutation{
		config:        c,
		op:            op,
		typ:           TypeRoleOrganization,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRole_OrganizationID sets the ID field of the mutation.
func withRole_OrganizationID(id string) roleOrganizationOption {
	return func(m *RoleOrganizationMutation) {
		var (
			err   error
			once  sync.Once
			value *Role_Organization
		)
		m.oldValue = func(ctx context.Context) (*Role_Organization, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role_Organization.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole_Organization sets the old Role_Organization of the mutation.
func withRole_Organization(node *Role_Organization) roleOrganizationOption {
	return func(m *RoleOrganizationMutation) {
		m.oldValue = func(context.Context) (*Role_Organization, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleOrganizationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleOrganizationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Role_Organization entities.
func (m *RoleOrganizationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleOrganizationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleOrganizationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role_Organization.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleOrganizationMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleOrganizationMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role_Organization entity.
// If the Role_Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleOrganizationMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *RoleOrganizationMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *RoleOrganizationMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleOrganizationMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RoleOrganizationMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RoleOrganizationMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Role_Organization entity.
// If the Role_Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleOrganizationMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *RoleOrganizationMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *RoleOrganizationMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RoleOrganizationMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *RoleOrganizationMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *RoleOrganizationMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Role_Organization entity.
// If the Role_Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleOrganizationMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *RoleOrganizationMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[role_organization.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *RoleOrganizationMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[role_organization.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *RoleOrganizationMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, role_organization.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *RoleOrganizationMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *RoleOrganizationMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Role_Organization entity.
// If the Role_Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleOrganizationMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *RoleOrganizationMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[role_organization.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *RoleOrganizationMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[role_organization.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *RoleOrganizationMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, role_organization.FieldUpdatedBy)
}

// SetRoleID sets the "role_id" field.
func (m *RoleOrganizationMutation) SetRoleID(s string) {
	m.roles = &s
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *RoleOrganizationMutation) RoleID() (r string, exists bool) {
	v := m.roles
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the Role_Organization entity.
// If the Role_Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleOrganizationMutation) OldRoleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *RoleOrganizationMutation) ResetRoleID() {
	m.roles = nil
}

// SetOrganizationID sets the "organization_id" field.
func (m *RoleOrganizationMutation) SetOrganizationID(s string) {
	m.organizations = &s
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *RoleOrganizationMutation) OrganizationID() (r string, exists bool) {
	v := m.organizations
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Role_Organization entity.
// If the Role_Organization object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleOrganizationMutation) OldOrganizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *RoleOrganizationMutation) ResetOrganizationID() {
	m.organizations = nil
}

// SetRolesID sets the "roles" edge to the Role entity by id.
func (m *RoleOrganizationMutation) SetRolesID(id string) {
	m.roles = &id
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *RoleOrganizationMutation) ClearRoles() {
	m.clearedroles = true
	m.clearedFields[role_organization.FieldRoleID] = struct{}{}
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *RoleOrganizationMutation) RolesCleared() bool {
	return m.clearedroles
}

// RolesID returns the "roles" edge ID in the mutation.
func (m *RoleOrganizationMutation) RolesID() (id string, exists bool) {
	if m.roles != nil {
		return *m.roles, true
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RolesID instead. It exists only for internal usage by the builders.
func (m *RoleOrganizationMutation) RolesIDs() (ids []string) {
	if id := m.roles; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *RoleOrganizationMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
}

// SetOrganizationsID sets the "organizations" edge to the Organization entity by id.
func (m *RoleOrganizationMutation) SetOrganizationsID(id string) {
	m.organizations = &id
}

// ClearOrganizations clears the "organizations" edge to the Organization entity.
func (m *RoleOrganizationMutation) ClearOrganizations() {
	m.clearedorganizations = true
	m.clearedFields[role_organization.FieldOrganizationID] = struct{}{}
}

// OrganizationsCleared reports if the "organizations" edge to the Organization entity was cleared.
func (m *RoleOrganizationMutation) OrganizationsCleared() bool {
	return m.clearedorganizations
}

// OrganizationsID returns the "organizations" edge ID in the mutation.
func (m *RoleOrganizationMutation) OrganizationsID() (id string, exists bool) {
	if m.organizations != nil {
		return *m.organizations, true
	}
	return
}

// OrganizationsIDs returns the "organizations" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationsID instead. It exists only for internal usage by the builders.
func (m *RoleOrganizationMutation) OrganizationsIDs() (ids []string) {
	if id := m.organizations; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganizations resets all changes to the "organizations" edge.
func (m *RoleOrganizationMutation) ResetOrganizations() {
	m.organizations = nil
	m.clearedorganizations = false
}

// Where appends a list predicates to the RoleOrganizationMutation builder.
func (m *RoleOrganizationMutation) Where(ps ...predicate.Role_Organization) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleOrganizationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleOrganizationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role_Organization, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleOrganizationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleOrganizationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role_Organization).
func (m *RoleOrganizationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleOrganizationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, role_organization.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, role_organization.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, role_organization.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, role_organization.FieldUpdatedBy)
	}
	if m.roles != nil {
		fields = append(fields, role_organization.FieldRoleID)
	}
	if m.organizations != nil {
		fields = append(fields, role_organization.FieldOrganizationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleOrganizationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role_organization.FieldCreatedAt:
		return m.CreatedAt()
	case role_organization.FieldUpdatedAt:
		return m.UpdatedAt()
	case role_organization.FieldCreatedBy:
		return m.CreatedBy()
	case role_organization.FieldUpdatedBy:
		return m.UpdatedBy()
	case role_organization.FieldRoleID:
		return m.RoleID()
	case role_organization.FieldOrganizationID:
		return m.OrganizationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleOrganizationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role_organization.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case role_organization.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case role_organization.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case role_organization.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case role_organization.FieldRoleID:
		return m.OldRoleID(ctx)
	case role_organization.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	}
	return nil, fmt.Errorf("unknown Role_Organization field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleOrganizationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role_organization.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case role_organization.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case role_organization.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case role_organization.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case role_organization.FieldRoleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case role_organization.FieldOrganizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	}
	return fmt.Errorf("unknown Role_Organization field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleOrganizationMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, role_organization.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, role_organization.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleOrganizationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case role_organization.FieldCreatedAt:
		return m.AddedCreatedAt()
	case role_organization.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleOrganizationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case role_organization.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case role_organization.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Role_Organization numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleOrganizationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role_organization.FieldCreatedBy) {
		fields = append(fields, role_organization.FieldCreatedBy)
	}
	if m.FieldCleared(role_organization.FieldUpdatedBy) {
		fields = append(fields, role_organization.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleOrganizationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleOrganizationMutation) ClearField(name string) error {
	switch name {
	case role_organization.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case role_organization.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Role_Organization nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleOrganizationMutation) ResetField(name string) error {
	switch name {
	case role_organization.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case role_organization.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case role_organization.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case role_organization.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case role_organization.FieldRoleID:
		m.ResetRoleID()
		return nil
	case role_organization.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	}
	return fmt.Errorf("unknown Role_Organization field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleOrganizationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.roles != nil {
		edges = append(edges, role_organization.EdgeRoles)
	}
	if m.organizations != nil {
		edges = append(edges, role_organization.EdgeOrganizations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleOrganizationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role_organization.EdgeRoles:
		if id := m.roles; id != nil {
			return []ent.Value{*id}
		}
	case role_organization.EdgeOrganizations:
		if id := m.organizations; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleOrganizationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleOrganizationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleOrganizationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedroles {
		edges = append(edges, role_organization.EdgeRoles)
	}
	if m.clearedorganizations {
		edges = append(edges, role_organization.EdgeOrganizations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleOrganizationMutation) EdgeCleared(name string) bool {
	switch name {
	case role_organization.EdgeRoles:
		return m.clearedroles
	case role_organization.EdgeOrganizations:
		return m.clearedorganizations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleOrganizationMutation) ClearEdge(name string) error {
	switch name {
	case role_organization.EdgeRoles:
		m.ClearRoles()
		return nil
	case role_organization.EdgeOrganizations:
		m.ClearOrganizations()
		return nil
	}
	return fmt.Errorf("unknown Role_Organization unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleOrganizationMutation) ResetEdge(name string) error {
	switch name {
	case role_organization.EdgeRoles:
		m.ResetRoles()
		return nil
	case role_organization.EdgeOrganizations:
		m.ResetOrganizations()
		return nil
	}
	return fmt.Errorf("unknown Role_Organization edge %s", name)
}

// StaffMutation represents an operation that mutates the Staff nodes in the graph.
type StaffMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	created_at          *int64
	addcreated_at       *int64
	updated_at          *int64
	addupdated_at       *int64
	created_by          *string
	updated_by          *string
	status              *string
	sort                *int32
	addsort             *int32
	remark              *string
	username            *string
	password            *string
	name                *string
	gender              *string
	work_status         *string
	mobile              *string
	email               *string
	avatar              *string
	clearedFields       map[string]struct{}
	organization        *string
	clearedorganization bool
	roles               map[string]struct{}
	removedroles        map[string]struct{}
	clearedroles        bool
	positions           map[string]struct{}
	removedpositions    map[string]struct{}
	clearedpositions    bool
	done                bool
	oldValue            func(context.Context) (*Staff, error)
	predicates          []predicate.Staff
}

var _ ent.Mutation = (*StaffMutation)(nil)

// staffOption allows management of the mutation configuration using functional options.
type staffOption func(*StaffMutation)

// newStaffMutation creates new mutation for the Staff entity.
func newStaffMutation(c config, op Op, opts ...staffOption) *StaffMutation {
	m := &StaffMutation{
		config:        c,
		op:            op,
		typ:           TypeStaff,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStaffID sets the ID field of the mutation.
func withStaffID(id string) staffOption {
	return func(m *StaffMutation) {
		var (
			err   error
			once  sync.Once
			value *Staff
		)
		m.oldValue = func(ctx context.Context) (*Staff, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Staff.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStaff sets the old Staff of the mutation.
func withStaff(node *Staff) staffOption {
	return func(m *StaffMutation) {
		m.oldValue = func(context.Context) (*Staff, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StaffMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StaffMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Staff entities.
func (m *StaffMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StaffMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StaffMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Staff.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StaffMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StaffMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Staff entity.
// If the Staff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *StaffMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *StaffMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StaffMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StaffMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StaffMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Staff entity.
// If the Staff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *StaffMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *StaffMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StaffMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *StaffMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *StaffMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Staff entity.
// If the Staff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *StaffMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[staff.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *StaffMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[staff.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *StaffMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, staff.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *StaffMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *StaffMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Staff entity.
// If the Staff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *StaffMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[staff.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *StaffMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[staff.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *StaffMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, staff.FieldUpdatedBy)
}

// SetStatus sets the "status" field.
func (m *StaffMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *StaffMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Staff entity.
// If the Staff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *StaffMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[staff.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *StaffMutation) StatusCleared() bool {
	_, ok := m.clearedFields[staff.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *StaffMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, staff.FieldStatus)
}

// SetSort sets the "sort" field.
func (m *StaffMutation) SetSort(i int32) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *StaffMutation) Sort() (r int32, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Staff entity.
// If the Staff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMutation) OldSort(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *StaffMutation) AddSort(i int32) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *StaffMutation) AddedSort() (r int32, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ClearSort clears the value of the "sort" field.
func (m *StaffMutation) ClearSort() {
	m.sort = nil
	m.addsort = nil
	m.clearedFields[staff.FieldSort] = struct{}{}
}

// SortCleared returns if the "sort" field was cleared in this mutation.
func (m *StaffMutation) SortCleared() bool {
	_, ok := m.clearedFields[staff.FieldSort]
	return ok
}

// ResetSort resets all changes to the "sort" field.
func (m *StaffMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
	delete(m.clearedFields, staff.FieldSort)
}

// SetRemark sets the "remark" field.
func (m *StaffMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *StaffMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Staff entity.
// If the Staff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *StaffMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[staff.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *StaffMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[staff.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *StaffMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, staff.FieldRemark)
}

// SetUsername sets the "username" field.
func (m *StaffMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *StaffMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the Staff entity.
// If the Staff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *StaffMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *StaffMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *StaffMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Staff entity.
// If the Staff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *StaffMutation) ResetPassword() {
	m.password = nil
}

// SetName sets the "name" field.
func (m *StaffMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StaffMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Staff entity.
// If the Staff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StaffMutation) ResetName() {
	m.name = nil
}

// SetGender sets the "gender" field.
func (m *StaffMutation) SetGender(s string) {
	m.gender = &s
}

// Gender returns the value of the "gender" field in the mutation.
func (m *StaffMutation) Gender() (r string, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Staff entity.
// If the Staff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ClearGender clears the value of the "gender" field.
func (m *StaffMutation) ClearGender() {
	m.gender = nil
	m.clearedFields[staff.FieldGender] = struct{}{}
}

// GenderCleared returns if the "gender" field was cleared in this mutation.
func (m *StaffMutation) GenderCleared() bool {
	_, ok := m.clearedFields[staff.FieldGender]
	return ok
}

// ResetGender resets all changes to the "gender" field.
func (m *StaffMutation) ResetGender() {
	m.gender = nil
	delete(m.clearedFields, staff.FieldGender)
}

// SetWorkStatus sets the "work_status" field.
func (m *StaffMutation) SetWorkStatus(s string) {
	m.work_status = &s
}

// WorkStatus returns the value of the "work_status" field in the mutation.
func (m *StaffMutation) WorkStatus() (r string, exists bool) {
	v := m.work_status
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkStatus returns the old "work_status" field's value of the Staff entity.
// If the Staff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMutation) OldWorkStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkStatus: %w", err)
	}
	return oldValue.WorkStatus, nil
}

// ClearWorkStatus clears the value of the "work_status" field.
func (m *StaffMutation) ClearWorkStatus() {
	m.work_status = nil
	m.clearedFields[staff.FieldWorkStatus] = struct{}{}
}

// WorkStatusCleared returns if the "work_status" field was cleared in this mutation.
func (m *StaffMutation) WorkStatusCleared() bool {
	_, ok := m.clearedFields[staff.FieldWorkStatus]
	return ok
}

// ResetWorkStatus resets all changes to the "work_status" field.
func (m *StaffMutation) ResetWorkStatus() {
	m.work_status = nil
	delete(m.clearedFields, staff.FieldWorkStatus)
}

// SetMobile sets the "mobile" field.
func (m *StaffMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *StaffMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the Staff entity.
// If the Staff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ResetMobile resets all changes to the "mobile" field.
func (m *StaffMutation) ResetMobile() {
	m.mobile = nil
}

// SetEmail sets the "email" field.
func (m *StaffMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *StaffMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Staff entity.
// If the Staff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *StaffMutation) ResetEmail() {
	m.email = nil
}

// SetAvatar sets the "avatar" field.
func (m *StaffMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *StaffMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the Staff entity.
// If the Staff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *StaffMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[staff.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *StaffMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[staff.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *StaffMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, staff.FieldAvatar)
}

// SetOrganizationID sets the "organization_id" field.
func (m *StaffMutation) SetOrganizationID(s string) {
	m.organization = &s
}

// OrganizationID returns the value of the "organization_id" field in the mutation.
func (m *StaffMutation) OrganizationID() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganizationID returns the old "organization_id" field's value of the Staff entity.
// If the Staff object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffMutation) OldOrganizationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrganizationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrganizationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganizationID: %w", err)
	}
	return oldValue.OrganizationID, nil
}

// ClearOrganizationID clears the value of the "organization_id" field.
func (m *StaffMutation) ClearOrganizationID() {
	m.organization = nil
	m.clearedFields[staff.FieldOrganizationID] = struct{}{}
}

// OrganizationIDCleared returns if the "organization_id" field was cleared in this mutation.
func (m *StaffMutation) OrganizationIDCleared() bool {
	_, ok := m.clearedFields[staff.FieldOrganizationID]
	return ok
}

// ResetOrganizationID resets all changes to the "organization_id" field.
func (m *StaffMutation) ResetOrganizationID() {
	m.organization = nil
	delete(m.clearedFields, staff.FieldOrganizationID)
}

// ClearOrganization clears the "organization" edge to the Organization entity.
func (m *StaffMutation) ClearOrganization() {
	m.clearedorganization = true
	m.clearedFields[staff.FieldOrganizationID] = struct{}{}
}

// OrganizationCleared reports if the "organization" edge to the Organization entity was cleared.
func (m *StaffMutation) OrganizationCleared() bool {
	return m.OrganizationIDCleared() || m.clearedorganization
}

// OrganizationIDs returns the "organization" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrganizationID instead. It exists only for internal usage by the builders.
func (m *StaffMutation) OrganizationIDs() (ids []string) {
	if id := m.organization; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrganization resets all changes to the "organization" edge.
func (m *StaffMutation) ResetOrganization() {
	m.organization = nil
	m.clearedorganization = false
}

// AddRoleIDs adds the "roles" edge to the Staff_Role entity by ids.
func (m *StaffMutation) AddRoleIDs(ids ...string) {
	if m.roles == nil {
		m.roles = make(map[string]struct{})
	}
	for i := range ids {
		m.roles[ids[i]] = struct{}{}
	}
}

// ClearRoles clears the "roles" edge to the Staff_Role entity.
func (m *StaffMutation) ClearRoles() {
	m.clearedroles = true
}

// RolesCleared reports if the "roles" edge to the Staff_Role entity was cleared.
func (m *StaffMutation) RolesCleared() bool {
	return m.clearedroles
}

// RemoveRoleIDs removes the "roles" edge to the Staff_Role entity by IDs.
func (m *StaffMutation) RemoveRoleIDs(ids ...string) {
	if m.removedroles == nil {
		m.removedroles = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.roles, ids[i])
		m.removedroles[ids[i]] = struct{}{}
	}
}

// RemovedRoles returns the removed IDs of the "roles" edge to the Staff_Role entity.
func (m *StaffMutation) RemovedRolesIDs() (ids []string) {
	for id := range m.removedroles {
		ids = append(ids, id)
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
func (m *StaffMutation) RolesIDs() (ids []string) {
	for id := range m.roles {
		ids = append(ids, id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *StaffMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
	m.removedroles = nil
}

// AddPositionIDs adds the "positions" edge to the Staff_Position entity by ids.
func (m *StaffMutation) AddPositionIDs(ids ...string) {
	if m.positions == nil {
		m.positions = make(map[string]struct{})
	}
	for i := range ids {
		m.positions[ids[i]] = struct{}{}
	}
}

// ClearPositions clears the "positions" edge to the Staff_Position entity.
func (m *StaffMutation) ClearPositions() {
	m.clearedpositions = true
}

// PositionsCleared reports if the "positions" edge to the Staff_Position entity was cleared.
func (m *StaffMutation) PositionsCleared() bool {
	return m.clearedpositions
}

// RemovePositionIDs removes the "positions" edge to the Staff_Position entity by IDs.
func (m *StaffMutation) RemovePositionIDs(ids ...string) {
	if m.removedpositions == nil {
		m.removedpositions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.positions, ids[i])
		m.removedpositions[ids[i]] = struct{}{}
	}
}

// RemovedPositions returns the removed IDs of the "positions" edge to the Staff_Position entity.
func (m *StaffMutation) RemovedPositionsIDs() (ids []string) {
	for id := range m.removedpositions {
		ids = append(ids, id)
	}
	return
}

// PositionsIDs returns the "positions" edge IDs in the mutation.
func (m *StaffMutation) PositionsIDs() (ids []string) {
	for id := range m.positions {
		ids = append(ids, id)
	}
	return
}

// ResetPositions resets all changes to the "positions" edge.
func (m *StaffMutation) ResetPositions() {
	m.positions = nil
	m.clearedpositions = false
	m.removedpositions = nil
}

// Where appends a list predicates to the StaffMutation builder.
func (m *StaffMutation) Where(ps ...predicate.Staff) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StaffMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StaffMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Staff, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StaffMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StaffMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Staff).
func (m *StaffMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StaffMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, staff.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, staff.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, staff.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, staff.FieldUpdatedBy)
	}
	if m.status != nil {
		fields = append(fields, staff.FieldStatus)
	}
	if m.sort != nil {
		fields = append(fields, staff.FieldSort)
	}
	if m.remark != nil {
		fields = append(fields, staff.FieldRemark)
	}
	if m.username != nil {
		fields = append(fields, staff.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, staff.FieldPassword)
	}
	if m.name != nil {
		fields = append(fields, staff.FieldName)
	}
	if m.gender != nil {
		fields = append(fields, staff.FieldGender)
	}
	if m.work_status != nil {
		fields = append(fields, staff.FieldWorkStatus)
	}
	if m.mobile != nil {
		fields = append(fields, staff.FieldMobile)
	}
	if m.email != nil {
		fields = append(fields, staff.FieldEmail)
	}
	if m.avatar != nil {
		fields = append(fields, staff.FieldAvatar)
	}
	if m.organization != nil {
		fields = append(fields, staff.FieldOrganizationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StaffMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case staff.FieldCreatedAt:
		return m.CreatedAt()
	case staff.FieldUpdatedAt:
		return m.UpdatedAt()
	case staff.FieldCreatedBy:
		return m.CreatedBy()
	case staff.FieldUpdatedBy:
		return m.UpdatedBy()
	case staff.FieldStatus:
		return m.Status()
	case staff.FieldSort:
		return m.Sort()
	case staff.FieldRemark:
		return m.Remark()
	case staff.FieldUsername:
		return m.Username()
	case staff.FieldPassword:
		return m.Password()
	case staff.FieldName:
		return m.Name()
	case staff.FieldGender:
		return m.Gender()
	case staff.FieldWorkStatus:
		return m.WorkStatus()
	case staff.FieldMobile:
		return m.Mobile()
	case staff.FieldEmail:
		return m.Email()
	case staff.FieldAvatar:
		return m.Avatar()
	case staff.FieldOrganizationID:
		return m.OrganizationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StaffMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case staff.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case staff.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case staff.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case staff.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case staff.FieldStatus:
		return m.OldStatus(ctx)
	case staff.FieldSort:
		return m.OldSort(ctx)
	case staff.FieldRemark:
		return m.OldRemark(ctx)
	case staff.FieldUsername:
		return m.OldUsername(ctx)
	case staff.FieldPassword:
		return m.OldPassword(ctx)
	case staff.FieldName:
		return m.OldName(ctx)
	case staff.FieldGender:
		return m.OldGender(ctx)
	case staff.FieldWorkStatus:
		return m.OldWorkStatus(ctx)
	case staff.FieldMobile:
		return m.OldMobile(ctx)
	case staff.FieldEmail:
		return m.OldEmail(ctx)
	case staff.FieldAvatar:
		return m.OldAvatar(ctx)
	case staff.FieldOrganizationID:
		return m.OldOrganizationID(ctx)
	}
	return nil, fmt.Errorf("unknown Staff field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StaffMutation) SetField(name string, value ent.Value) error {
	switch name {
	case staff.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case staff.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case staff.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case staff.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case staff.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case staff.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case staff.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case staff.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case staff.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case staff.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case staff.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case staff.FieldWorkStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkStatus(v)
		return nil
	case staff.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case staff.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case staff.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case staff.FieldOrganizationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganizationID(v)
		return nil
	}
	return fmt.Errorf("unknown Staff field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StaffMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, staff.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, staff.FieldUpdatedAt)
	}
	if m.addsort != nil {
		fields = append(fields, staff.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StaffMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case staff.FieldCreatedAt:
		return m.AddedCreatedAt()
	case staff.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	case staff.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StaffMutation) AddField(name string, value ent.Value) error {
	switch name {
	case staff.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case staff.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	case staff.FieldSort:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown Staff numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StaffMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(staff.FieldCreatedBy) {
		fields = append(fields, staff.FieldCreatedBy)
	}
	if m.FieldCleared(staff.FieldUpdatedBy) {
		fields = append(fields, staff.FieldUpdatedBy)
	}
	if m.FieldCleared(staff.FieldStatus) {
		fields = append(fields, staff.FieldStatus)
	}
	if m.FieldCleared(staff.FieldSort) {
		fields = append(fields, staff.FieldSort)
	}
	if m.FieldCleared(staff.FieldRemark) {
		fields = append(fields, staff.FieldRemark)
	}
	if m.FieldCleared(staff.FieldGender) {
		fields = append(fields, staff.FieldGender)
	}
	if m.FieldCleared(staff.FieldWorkStatus) {
		fields = append(fields, staff.FieldWorkStatus)
	}
	if m.FieldCleared(staff.FieldAvatar) {
		fields = append(fields, staff.FieldAvatar)
	}
	if m.FieldCleared(staff.FieldOrganizationID) {
		fields = append(fields, staff.FieldOrganizationID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StaffMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StaffMutation) ClearField(name string) error {
	switch name {
	case staff.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case staff.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case staff.FieldStatus:
		m.ClearStatus()
		return nil
	case staff.FieldSort:
		m.ClearSort()
		return nil
	case staff.FieldRemark:
		m.ClearRemark()
		return nil
	case staff.FieldGender:
		m.ClearGender()
		return nil
	case staff.FieldWorkStatus:
		m.ClearWorkStatus()
		return nil
	case staff.FieldAvatar:
		m.ClearAvatar()
		return nil
	case staff.FieldOrganizationID:
		m.ClearOrganizationID()
		return nil
	}
	return fmt.Errorf("unknown Staff nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StaffMutation) ResetField(name string) error {
	switch name {
	case staff.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case staff.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case staff.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case staff.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case staff.FieldStatus:
		m.ResetStatus()
		return nil
	case staff.FieldSort:
		m.ResetSort()
		return nil
	case staff.FieldRemark:
		m.ResetRemark()
		return nil
	case staff.FieldUsername:
		m.ResetUsername()
		return nil
	case staff.FieldPassword:
		m.ResetPassword()
		return nil
	case staff.FieldName:
		m.ResetName()
		return nil
	case staff.FieldGender:
		m.ResetGender()
		return nil
	case staff.FieldWorkStatus:
		m.ResetWorkStatus()
		return nil
	case staff.FieldMobile:
		m.ResetMobile()
		return nil
	case staff.FieldEmail:
		m.ResetEmail()
		return nil
	case staff.FieldAvatar:
		m.ResetAvatar()
		return nil
	case staff.FieldOrganizationID:
		m.ResetOrganizationID()
		return nil
	}
	return fmt.Errorf("unknown Staff field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StaffMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.organization != nil {
		edges = append(edges, staff.EdgeOrganization)
	}
	if m.roles != nil {
		edges = append(edges, staff.EdgeRoles)
	}
	if m.positions != nil {
		edges = append(edges, staff.EdgePositions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StaffMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case staff.EdgeOrganization:
		if id := m.organization; id != nil {
			return []ent.Value{*id}
		}
	case staff.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.roles))
		for id := range m.roles {
			ids = append(ids, id)
		}
		return ids
	case staff.EdgePositions:
		ids := make([]ent.Value, 0, len(m.positions))
		for id := range m.positions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StaffMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedroles != nil {
		edges = append(edges, staff.EdgeRoles)
	}
	if m.removedpositions != nil {
		edges = append(edges, staff.EdgePositions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StaffMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case staff.EdgeRoles:
		ids := make([]ent.Value, 0, len(m.removedroles))
		for id := range m.removedroles {
			ids = append(ids, id)
		}
		return ids
	case staff.EdgePositions:
		ids := make([]ent.Value, 0, len(m.removedpositions))
		for id := range m.removedpositions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StaffMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedorganization {
		edges = append(edges, staff.EdgeOrganization)
	}
	if m.clearedroles {
		edges = append(edges, staff.EdgeRoles)
	}
	if m.clearedpositions {
		edges = append(edges, staff.EdgePositions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StaffMutation) EdgeCleared(name string) bool {
	switch name {
	case staff.EdgeOrganization:
		return m.clearedorganization
	case staff.EdgeRoles:
		return m.clearedroles
	case staff.EdgePositions:
		return m.clearedpositions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StaffMutation) ClearEdge(name string) error {
	switch name {
	case staff.EdgeOrganization:
		m.ClearOrganization()
		return nil
	}
	return fmt.Errorf("unknown Staff unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StaffMutation) ResetEdge(name string) error {
	switch name {
	case staff.EdgeOrganization:
		m.ResetOrganization()
		return nil
	case staff.EdgeRoles:
		m.ResetRoles()
		return nil
	case staff.EdgePositions:
		m.ResetPositions()
		return nil
	}
	return fmt.Errorf("unknown Staff edge %s", name)
}

// StaffPositionMutation represents an operation that mutates the Staff_Position nodes in the graph.
type StaffPositionMutation struct {
	config
	op               Op
	typ              string
	id               *string
	created_at       *int64
	addcreated_at    *int64
	updated_at       *int64
	addupdated_at    *int64
	created_by       *string
	updated_by       *string
	clearedFields    map[string]struct{}
	staffs           *string
	clearedstaffs    bool
	positions        *string
	clearedpositions bool
	done             bool
	oldValue         func(context.Context) (*Staff_Position, error)
	predicates       []predicate.Staff_Position
}

var _ ent.Mutation = (*StaffPositionMutation)(nil)

// staffPositionOption allows management of the mutation configuration using functional options.
type staffPositionOption func(*StaffPositionMutation)

// newStaffPositionMutation creates new mutation for the Staff_Position entity.
func newStaffPositionMutation(c config, op Op, opts ...staffPositionOption) *StaffPositionMutation {
	m := &StaffPositionMutation{
		config:        c,
		op:            op,
		typ:           TypeStaffPosition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStaff_PositionID sets the ID field of the mutation.
func withStaff_PositionID(id string) staffPositionOption {
	return func(m *StaffPositionMutation) {
		var (
			err   error
			once  sync.Once
			value *Staff_Position
		)
		m.oldValue = func(ctx context.Context) (*Staff_Position, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Staff_Position.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStaff_Position sets the old Staff_Position of the mutation.
func withStaff_Position(node *Staff_Position) staffPositionOption {
	return func(m *StaffPositionMutation) {
		m.oldValue = func(context.Context) (*Staff_Position, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StaffPositionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StaffPositionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Staff_Position entities.
func (m *StaffPositionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StaffPositionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StaffPositionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Staff_Position.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StaffPositionMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StaffPositionMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Staff_Position entity.
// If the Staff_Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffPositionMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *StaffPositionMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *StaffPositionMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StaffPositionMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StaffPositionMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StaffPositionMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Staff_Position entity.
// If the Staff_Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffPositionMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *StaffPositionMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *StaffPositionMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StaffPositionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *StaffPositionMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *StaffPositionMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Staff_Position entity.
// If the Staff_Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffPositionMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *StaffPositionMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[staff_position.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *StaffPositionMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[staff_position.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *StaffPositionMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, staff_position.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *StaffPositionMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *StaffPositionMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Staff_Position entity.
// If the Staff_Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffPositionMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *StaffPositionMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[staff_position.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *StaffPositionMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[staff_position.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *StaffPositionMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, staff_position.FieldUpdatedBy)
}

// SetStaffID sets the "staff_id" field.
func (m *StaffPositionMutation) SetStaffID(s string) {
	m.staffs = &s
}

// StaffID returns the value of the "staff_id" field in the mutation.
func (m *StaffPositionMutation) StaffID() (r string, exists bool) {
	v := m.staffs
	if v == nil {
		return
	}
	return *v, true
}

// OldStaffID returns the old "staff_id" field's value of the Staff_Position entity.
// If the Staff_Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffPositionMutation) OldStaffID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStaffID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStaffID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStaffID: %w", err)
	}
	return oldValue.StaffID, nil
}

// ResetStaffID resets all changes to the "staff_id" field.
func (m *StaffPositionMutation) ResetStaffID() {
	m.staffs = nil
}

// SetPositionID sets the "position_id" field.
func (m *StaffPositionMutation) SetPositionID(s string) {
	m.positions = &s
}

// PositionID returns the value of the "position_id" field in the mutation.
func (m *StaffPositionMutation) PositionID() (r string, exists bool) {
	v := m.positions
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionID returns the old "position_id" field's value of the Staff_Position entity.
// If the Staff_Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffPositionMutation) OldPositionID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPositionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPositionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionID: %w", err)
	}
	return oldValue.PositionID, nil
}

// ResetPositionID resets all changes to the "position_id" field.
func (m *StaffPositionMutation) ResetPositionID() {
	m.positions = nil
}

// SetStaffsID sets the "staffs" edge to the Staff entity by id.
func (m *StaffPositionMutation) SetStaffsID(id string) {
	m.staffs = &id
}

// ClearStaffs clears the "staffs" edge to the Staff entity.
func (m *StaffPositionMutation) ClearStaffs() {
	m.clearedstaffs = true
	m.clearedFields[staff_position.FieldStaffID] = struct{}{}
}

// StaffsCleared reports if the "staffs" edge to the Staff entity was cleared.
func (m *StaffPositionMutation) StaffsCleared() bool {
	return m.clearedstaffs
}

// StaffsID returns the "staffs" edge ID in the mutation.
func (m *StaffPositionMutation) StaffsID() (id string, exists bool) {
	if m.staffs != nil {
		return *m.staffs, true
	}
	return
}

// StaffsIDs returns the "staffs" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StaffsID instead. It exists only for internal usage by the builders.
func (m *StaffPositionMutation) StaffsIDs() (ids []string) {
	if id := m.staffs; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStaffs resets all changes to the "staffs" edge.
func (m *StaffPositionMutation) ResetStaffs() {
	m.staffs = nil
	m.clearedstaffs = false
}

// SetPositionsID sets the "positions" edge to the Position entity by id.
func (m *StaffPositionMutation) SetPositionsID(id string) {
	m.positions = &id
}

// ClearPositions clears the "positions" edge to the Position entity.
func (m *StaffPositionMutation) ClearPositions() {
	m.clearedpositions = true
	m.clearedFields[staff_position.FieldPositionID] = struct{}{}
}

// PositionsCleared reports if the "positions" edge to the Position entity was cleared.
func (m *StaffPositionMutation) PositionsCleared() bool {
	return m.clearedpositions
}

// PositionsID returns the "positions" edge ID in the mutation.
func (m *StaffPositionMutation) PositionsID() (id string, exists bool) {
	if m.positions != nil {
		return *m.positions, true
	}
	return
}

// PositionsIDs returns the "positions" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PositionsID instead. It exists only for internal usage by the builders.
func (m *StaffPositionMutation) PositionsIDs() (ids []string) {
	if id := m.positions; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPositions resets all changes to the "positions" edge.
func (m *StaffPositionMutation) ResetPositions() {
	m.positions = nil
	m.clearedpositions = false
}

// Where appends a list predicates to the StaffPositionMutation builder.
func (m *StaffPositionMutation) Where(ps ...predicate.Staff_Position) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StaffPositionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StaffPositionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Staff_Position, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StaffPositionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StaffPositionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Staff_Position).
func (m *StaffPositionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StaffPositionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, staff_position.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, staff_position.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, staff_position.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, staff_position.FieldUpdatedBy)
	}
	if m.staffs != nil {
		fields = append(fields, staff_position.FieldStaffID)
	}
	if m.positions != nil {
		fields = append(fields, staff_position.FieldPositionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StaffPositionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case staff_position.FieldCreatedAt:
		return m.CreatedAt()
	case staff_position.FieldUpdatedAt:
		return m.UpdatedAt()
	case staff_position.FieldCreatedBy:
		return m.CreatedBy()
	case staff_position.FieldUpdatedBy:
		return m.UpdatedBy()
	case staff_position.FieldStaffID:
		return m.StaffID()
	case staff_position.FieldPositionID:
		return m.PositionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StaffPositionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case staff_position.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case staff_position.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case staff_position.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case staff_position.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case staff_position.FieldStaffID:
		return m.OldStaffID(ctx)
	case staff_position.FieldPositionID:
		return m.OldPositionID(ctx)
	}
	return nil, fmt.Errorf("unknown Staff_Position field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StaffPositionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case staff_position.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case staff_position.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case staff_position.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case staff_position.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case staff_position.FieldStaffID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStaffID(v)
		return nil
	case staff_position.FieldPositionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionID(v)
		return nil
	}
	return fmt.Errorf("unknown Staff_Position field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StaffPositionMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, staff_position.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, staff_position.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StaffPositionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case staff_position.FieldCreatedAt:
		return m.AddedCreatedAt()
	case staff_position.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StaffPositionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case staff_position.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case staff_position.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Staff_Position numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StaffPositionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(staff_position.FieldCreatedBy) {
		fields = append(fields, staff_position.FieldCreatedBy)
	}
	if m.FieldCleared(staff_position.FieldUpdatedBy) {
		fields = append(fields, staff_position.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StaffPositionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StaffPositionMutation) ClearField(name string) error {
	switch name {
	case staff_position.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case staff_position.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Staff_Position nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StaffPositionMutation) ResetField(name string) error {
	switch name {
	case staff_position.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case staff_position.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case staff_position.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case staff_position.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case staff_position.FieldStaffID:
		m.ResetStaffID()
		return nil
	case staff_position.FieldPositionID:
		m.ResetPositionID()
		return nil
	}
	return fmt.Errorf("unknown Staff_Position field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StaffPositionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.staffs != nil {
		edges = append(edges, staff_position.EdgeStaffs)
	}
	if m.positions != nil {
		edges = append(edges, staff_position.EdgePositions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StaffPositionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case staff_position.EdgeStaffs:
		if id := m.staffs; id != nil {
			return []ent.Value{*id}
		}
	case staff_position.EdgePositions:
		if id := m.positions; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StaffPositionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StaffPositionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StaffPositionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstaffs {
		edges = append(edges, staff_position.EdgeStaffs)
	}
	if m.clearedpositions {
		edges = append(edges, staff_position.EdgePositions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StaffPositionMutation) EdgeCleared(name string) bool {
	switch name {
	case staff_position.EdgeStaffs:
		return m.clearedstaffs
	case staff_position.EdgePositions:
		return m.clearedpositions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StaffPositionMutation) ClearEdge(name string) error {
	switch name {
	case staff_position.EdgeStaffs:
		m.ClearStaffs()
		return nil
	case staff_position.EdgePositions:
		m.ClearPositions()
		return nil
	}
	return fmt.Errorf("unknown Staff_Position unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StaffPositionMutation) ResetEdge(name string) error {
	switch name {
	case staff_position.EdgeStaffs:
		m.ResetStaffs()
		return nil
	case staff_position.EdgePositions:
		m.ResetPositions()
		return nil
	}
	return fmt.Errorf("unknown Staff_Position edge %s", name)
}

// StaffRoleMutation represents an operation that mutates the Staff_Role nodes in the graph.
type StaffRoleMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *int64
	addcreated_at *int64
	updated_at    *int64
	addupdated_at *int64
	created_by    *string
	updated_by    *string
	clearedFields map[string]struct{}
	staffs        *string
	clearedstaffs bool
	roles         *string
	clearedroles  bool
	done          bool
	oldValue      func(context.Context) (*Staff_Role, error)
	predicates    []predicate.Staff_Role
}

var _ ent.Mutation = (*StaffRoleMutation)(nil)

// staffRoleOption allows management of the mutation configuration using functional options.
type staffRoleOption func(*StaffRoleMutation)

// newStaffRoleMutation creates new mutation for the Staff_Role entity.
func newStaffRoleMutation(c config, op Op, opts ...staffRoleOption) *StaffRoleMutation {
	m := &StaffRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeStaffRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStaff_RoleID sets the ID field of the mutation.
func withStaff_RoleID(id string) staffRoleOption {
	return func(m *StaffRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Staff_Role
		)
		m.oldValue = func(ctx context.Context) (*Staff_Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Staff_Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStaff_Role sets the old Staff_Role of the mutation.
func withStaff_Role(node *Staff_Role) staffRoleOption {
	return func(m *StaffRoleMutation) {
		m.oldValue = func(context.Context) (*Staff_Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StaffRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StaffRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Staff_Role entities.
func (m *StaffRoleMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StaffRoleMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StaffRoleMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Staff_Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StaffRoleMutation) SetCreatedAt(i int64) {
	m.created_at = &i
	m.addcreated_at = nil
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StaffRoleMutation) CreatedAt() (r int64, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Staff_Role entity.
// If the Staff_Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffRoleMutation) OldCreatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// AddCreatedAt adds i to the "created_at" field.
func (m *StaffRoleMutation) AddCreatedAt(i int64) {
	if m.addcreated_at != nil {
		*m.addcreated_at += i
	} else {
		m.addcreated_at = &i
	}
}

// AddedCreatedAt returns the value that was added to the "created_at" field in this mutation.
func (m *StaffRoleMutation) AddedCreatedAt() (r int64, exists bool) {
	v := m.addcreated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StaffRoleMutation) ResetCreatedAt() {
	m.created_at = nil
	m.addcreated_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StaffRoleMutation) SetUpdatedAt(i int64) {
	m.updated_at = &i
	m.addupdated_at = nil
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StaffRoleMutation) UpdatedAt() (r int64, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Staff_Role entity.
// If the Staff_Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffRoleMutation) OldUpdatedAt(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// AddUpdatedAt adds i to the "updated_at" field.
func (m *StaffRoleMutation) AddUpdatedAt(i int64) {
	if m.addupdated_at != nil {
		*m.addupdated_at += i
	} else {
		m.addupdated_at = &i
	}
}

// AddedUpdatedAt returns the value that was added to the "updated_at" field in this mutation.
func (m *StaffRoleMutation) AddedUpdatedAt() (r int64, exists bool) {
	v := m.addupdated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StaffRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	m.addupdated_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *StaffRoleMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *StaffRoleMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Staff_Role entity.
// If the Staff_Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffRoleMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *StaffRoleMutation) ClearCreatedBy() {
	m.created_by = nil
	m.clearedFields[staff_role.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *StaffRoleMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[staff_role.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *StaffRoleMutation) ResetCreatedBy() {
	m.created_by = nil
	delete(m.clearedFields, staff_role.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *StaffRoleMutation) SetUpdatedBy(s string) {
	m.updated_by = &s
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *StaffRoleMutation) UpdatedBy() (r string, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Staff_Role entity.
// If the Staff_Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffRoleMutation) OldUpdatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *StaffRoleMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.clearedFields[staff_role.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *StaffRoleMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[staff_role.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *StaffRoleMutation) ResetUpdatedBy() {
	m.updated_by = nil
	delete(m.clearedFields, staff_role.FieldUpdatedBy)
}

// SetStaffID sets the "staff_id" field.
func (m *StaffRoleMutation) SetStaffID(s string) {
	m.staffs = &s
}

// StaffID returns the value of the "staff_id" field in the mutation.
func (m *StaffRoleMutation) StaffID() (r string, exists bool) {
	v := m.staffs
	if v == nil {
		return
	}
	return *v, true
}

// OldStaffID returns the old "staff_id" field's value of the Staff_Role entity.
// If the Staff_Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffRoleMutation) OldStaffID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStaffID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStaffID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStaffID: %w", err)
	}
	return oldValue.StaffID, nil
}

// ResetStaffID resets all changes to the "staff_id" field.
func (m *StaffRoleMutation) ResetStaffID() {
	m.staffs = nil
}

// SetRoleID sets the "role_id" field.
func (m *StaffRoleMutation) SetRoleID(s string) {
	m.roles = &s
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *StaffRoleMutation) RoleID() (r string, exists bool) {
	v := m.roles
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the Staff_Role entity.
// If the Staff_Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StaffRoleMutation) OldRoleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *StaffRoleMutation) ResetRoleID() {
	m.roles = nil
}

// SetStaffsID sets the "staffs" edge to the Staff entity by id.
func (m *StaffRoleMutation) SetStaffsID(id string) {
	m.staffs = &id
}

// ClearStaffs clears the "staffs" edge to the Staff entity.
func (m *StaffRoleMutation) ClearStaffs() {
	m.clearedstaffs = true
	m.clearedFields[staff_role.FieldStaffID] = struct{}{}
}

// StaffsCleared reports if the "staffs" edge to the Staff entity was cleared.
func (m *StaffRoleMutation) StaffsCleared() bool {
	return m.clearedstaffs
}

// StaffsID returns the "staffs" edge ID in the mutation.
func (m *StaffRoleMutation) StaffsID() (id string, exists bool) {
	if m.staffs != nil {
		return *m.staffs, true
	}
	return
}

// StaffsIDs returns the "staffs" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StaffsID instead. It exists only for internal usage by the builders.
func (m *StaffRoleMutation) StaffsIDs() (ids []string) {
	if id := m.staffs; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStaffs resets all changes to the "staffs" edge.
func (m *StaffRoleMutation) ResetStaffs() {
	m.staffs = nil
	m.clearedstaffs = false
}

// SetRolesID sets the "roles" edge to the Role entity by id.
func (m *StaffRoleMutation) SetRolesID(id string) {
	m.roles = &id
}

// ClearRoles clears the "roles" edge to the Role entity.
func (m *StaffRoleMutation) ClearRoles() {
	m.clearedroles = true
	m.clearedFields[staff_role.FieldRoleID] = struct{}{}
}

// RolesCleared reports if the "roles" edge to the Role entity was cleared.
func (m *StaffRoleMutation) RolesCleared() bool {
	return m.clearedroles
}

// RolesID returns the "roles" edge ID in the mutation.
func (m *StaffRoleMutation) RolesID() (id string, exists bool) {
	if m.roles != nil {
		return *m.roles, true
	}
	return
}

// RolesIDs returns the "roles" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RolesID instead. It exists only for internal usage by the builders.
func (m *StaffRoleMutation) RolesIDs() (ids []string) {
	if id := m.roles; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoles resets all changes to the "roles" edge.
func (m *StaffRoleMutation) ResetRoles() {
	m.roles = nil
	m.clearedroles = false
}

// Where appends a list predicates to the StaffRoleMutation builder.
func (m *StaffRoleMutation) Where(ps ...predicate.Staff_Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StaffRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StaffRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Staff_Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StaffRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StaffRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Staff_Role).
func (m *StaffRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StaffRoleMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, staff_role.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, staff_role.FieldUpdatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, staff_role.FieldCreatedBy)
	}
	if m.updated_by != nil {
		fields = append(fields, staff_role.FieldUpdatedBy)
	}
	if m.staffs != nil {
		fields = append(fields, staff_role.FieldStaffID)
	}
	if m.roles != nil {
		fields = append(fields, staff_role.FieldRoleID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StaffRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case staff_role.FieldCreatedAt:
		return m.CreatedAt()
	case staff_role.FieldUpdatedAt:
		return m.UpdatedAt()
	case staff_role.FieldCreatedBy:
		return m.CreatedBy()
	case staff_role.FieldUpdatedBy:
		return m.UpdatedBy()
	case staff_role.FieldStaffID:
		return m.StaffID()
	case staff_role.FieldRoleID:
		return m.RoleID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StaffRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case staff_role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case staff_role.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case staff_role.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case staff_role.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case staff_role.FieldStaffID:
		return m.OldStaffID(ctx)
	case staff_role.FieldRoleID:
		return m.OldRoleID(ctx)
	}
	return nil, fmt.Errorf("unknown Staff_Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StaffRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case staff_role.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case staff_role.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case staff_role.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case staff_role.FieldUpdatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case staff_role.FieldStaffID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStaffID(v)
		return nil
	case staff_role.FieldRoleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown Staff_Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StaffRoleMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_at != nil {
		fields = append(fields, staff_role.FieldCreatedAt)
	}
	if m.addupdated_at != nil {
		fields = append(fields, staff_role.FieldUpdatedAt)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StaffRoleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case staff_role.FieldCreatedAt:
		return m.AddedCreatedAt()
	case staff_role.FieldUpdatedAt:
		return m.AddedUpdatedAt()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StaffRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case staff_role.FieldCreatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedAt(v)
		return nil
	case staff_role.FieldUpdatedAt:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Staff_Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StaffRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(staff_role.FieldCreatedBy) {
		fields = append(fields, staff_role.FieldCreatedBy)
	}
	if m.FieldCleared(staff_role.FieldUpdatedBy) {
		fields = append(fields, staff_role.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StaffRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StaffRoleMutation) ClearField(name string) error {
	switch name {
	case staff_role.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case staff_role.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Staff_Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StaffRoleMutation) ResetField(name string) error {
	switch name {
	case staff_role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case staff_role.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case staff_role.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case staff_role.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case staff_role.FieldStaffID:
		m.ResetStaffID()
		return nil
	case staff_role.FieldRoleID:
		m.ResetRoleID()
		return nil
	}
	return fmt.Errorf("unknown Staff_Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StaffRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.staffs != nil {
		edges = append(edges, staff_role.EdgeStaffs)
	}
	if m.roles != nil {
		edges = append(edges, staff_role.EdgeRoles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StaffRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case staff_role.EdgeStaffs:
		if id := m.staffs; id != nil {
			return []ent.Value{*id}
		}
	case staff_role.EdgeRoles:
		if id := m.roles; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StaffRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StaffRoleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StaffRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstaffs {
		edges = append(edges, staff_role.EdgeStaffs)
	}
	if m.clearedroles {
		edges = append(edges, staff_role.EdgeRoles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StaffRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case staff_role.EdgeStaffs:
		return m.clearedstaffs
	case staff_role.EdgeRoles:
		return m.clearedroles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StaffRoleMutation) ClearEdge(name string) error {
	switch name {
	case staff_role.EdgeStaffs:
		m.ClearStaffs()
		return nil
	case staff_role.EdgeRoles:
		m.ClearRoles()
		return nil
	}
	return fmt.Errorf("unknown Staff_Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StaffRoleMutation) ResetEdge(name string) error {
	switch name {
	case staff_role.EdgeStaffs:
		m.ResetStaffs()
		return nil
	case staff_role.EdgeRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown Staff_Role edge %s", name)
}
