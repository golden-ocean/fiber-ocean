// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/golden-ocean/fiber-ocean/ent/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/golden-ocean/fiber-ocean/ent/dictionary"
	"github.com/golden-ocean/fiber-ocean/ent/dictionary_item"
	"github.com/golden-ocean/fiber-ocean/ent/menu"
	"github.com/golden-ocean/fiber-ocean/ent/organization"
	"github.com/golden-ocean/fiber-ocean/ent/position"
	"github.com/golden-ocean/fiber-ocean/ent/role"
	"github.com/golden-ocean/fiber-ocean/ent/role_menu"
	"github.com/golden-ocean/fiber-ocean/ent/role_organization"
	"github.com/golden-ocean/fiber-ocean/ent/staff"
	"github.com/golden-ocean/fiber-ocean/ent/staff_position"
	"github.com/golden-ocean/fiber-ocean/ent/staff_role"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Dictionary is the client for interacting with the Dictionary builders.
	Dictionary *DictionaryClient
	// Dictionary_Item is the client for interacting with the Dictionary_Item builders.
	Dictionary_Item *DictionaryItemClient
	// Menu is the client for interacting with the Menu builders.
	Menu *MenuClient
	// Organization is the client for interacting with the Organization builders.
	Organization *OrganizationClient
	// Position is the client for interacting with the Position builders.
	Position *PositionClient
	// Role is the client for interacting with the Role builders.
	Role *RoleClient
	// Role_Menu is the client for interacting with the Role_Menu builders.
	Role_Menu *RoleMenuClient
	// Role_Organization is the client for interacting with the Role_Organization builders.
	Role_Organization *RoleOrganizationClient
	// Staff is the client for interacting with the Staff builders.
	Staff *StaffClient
	// Staff_Position is the client for interacting with the Staff_Position builders.
	Staff_Position *StaffPositionClient
	// Staff_Role is the client for interacting with the Staff_Role builders.
	Staff_Role *StaffRoleClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Dictionary = NewDictionaryClient(c.config)
	c.Dictionary_Item = NewDictionaryItemClient(c.config)
	c.Menu = NewMenuClient(c.config)
	c.Organization = NewOrganizationClient(c.config)
	c.Position = NewPositionClient(c.config)
	c.Role = NewRoleClient(c.config)
	c.Role_Menu = NewRoleMenuClient(c.config)
	c.Role_Organization = NewRoleOrganizationClient(c.config)
	c.Staff = NewStaffClient(c.config)
	c.Staff_Position = NewStaffPositionClient(c.config)
	c.Staff_Role = NewStaffRoleClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		Dictionary:        NewDictionaryClient(cfg),
		Dictionary_Item:   NewDictionaryItemClient(cfg),
		Menu:              NewMenuClient(cfg),
		Organization:      NewOrganizationClient(cfg),
		Position:          NewPositionClient(cfg),
		Role:              NewRoleClient(cfg),
		Role_Menu:         NewRoleMenuClient(cfg),
		Role_Organization: NewRoleOrganizationClient(cfg),
		Staff:             NewStaffClient(cfg),
		Staff_Position:    NewStaffPositionClient(cfg),
		Staff_Role:        NewStaffRoleClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		Dictionary:        NewDictionaryClient(cfg),
		Dictionary_Item:   NewDictionaryItemClient(cfg),
		Menu:              NewMenuClient(cfg),
		Organization:      NewOrganizationClient(cfg),
		Position:          NewPositionClient(cfg),
		Role:              NewRoleClient(cfg),
		Role_Menu:         NewRoleMenuClient(cfg),
		Role_Organization: NewRoleOrganizationClient(cfg),
		Staff:             NewStaffClient(cfg),
		Staff_Position:    NewStaffPositionClient(cfg),
		Staff_Role:        NewStaffRoleClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Dictionary.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Dictionary, c.Dictionary_Item, c.Menu, c.Organization, c.Position, c.Role,
		c.Role_Menu, c.Role_Organization, c.Staff, c.Staff_Position, c.Staff_Role,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Dictionary, c.Dictionary_Item, c.Menu, c.Organization, c.Position, c.Role,
		c.Role_Menu, c.Role_Organization, c.Staff, c.Staff_Position, c.Staff_Role,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *DictionaryMutation:
		return c.Dictionary.mutate(ctx, m)
	case *DictionaryItemMutation:
		return c.Dictionary_Item.mutate(ctx, m)
	case *MenuMutation:
		return c.Menu.mutate(ctx, m)
	case *OrganizationMutation:
		return c.Organization.mutate(ctx, m)
	case *PositionMutation:
		return c.Position.mutate(ctx, m)
	case *RoleMutation:
		return c.Role.mutate(ctx, m)
	case *RoleMenuMutation:
		return c.Role_Menu.mutate(ctx, m)
	case *RoleOrganizationMutation:
		return c.Role_Organization.mutate(ctx, m)
	case *StaffMutation:
		return c.Staff.mutate(ctx, m)
	case *StaffPositionMutation:
		return c.Staff_Position.mutate(ctx, m)
	case *StaffRoleMutation:
		return c.Staff_Role.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// DictionaryClient is a client for the Dictionary schema.
type DictionaryClient struct {
	config
}

// NewDictionaryClient returns a client for the Dictionary from the given config.
func NewDictionaryClient(c config) *DictionaryClient {
	return &DictionaryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dictionary.Hooks(f(g(h())))`.
func (c *DictionaryClient) Use(hooks ...Hook) {
	c.hooks.Dictionary = append(c.hooks.Dictionary, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dictionary.Intercept(f(g(h())))`.
func (c *DictionaryClient) Intercept(interceptors ...Interceptor) {
	c.inters.Dictionary = append(c.inters.Dictionary, interceptors...)
}

// Create returns a builder for creating a Dictionary entity.
func (c *DictionaryClient) Create() *DictionaryCreate {
	mutation := newDictionaryMutation(c.config, OpCreate)
	return &DictionaryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Dictionary entities.
func (c *DictionaryClient) CreateBulk(builders ...*DictionaryCreate) *DictionaryCreateBulk {
	return &DictionaryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DictionaryClient) MapCreateBulk(slice any, setFunc func(*DictionaryCreate, int)) *DictionaryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DictionaryCreateBulk{err: fmt.Errorf("calling to DictionaryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DictionaryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DictionaryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Dictionary.
func (c *DictionaryClient) Update() *DictionaryUpdate {
	mutation := newDictionaryMutation(c.config, OpUpdate)
	return &DictionaryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DictionaryClient) UpdateOne(d *Dictionary) *DictionaryUpdateOne {
	mutation := newDictionaryMutation(c.config, OpUpdateOne, withDictionary(d))
	return &DictionaryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DictionaryClient) UpdateOneID(id string) *DictionaryUpdateOne {
	mutation := newDictionaryMutation(c.config, OpUpdateOne, withDictionaryID(id))
	return &DictionaryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Dictionary.
func (c *DictionaryClient) Delete() *DictionaryDelete {
	mutation := newDictionaryMutation(c.config, OpDelete)
	return &DictionaryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DictionaryClient) DeleteOne(d *Dictionary) *DictionaryDeleteOne {
	return c.DeleteOneID(d.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DictionaryClient) DeleteOneID(id string) *DictionaryDeleteOne {
	builder := c.Delete().Where(dictionary.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DictionaryDeleteOne{builder}
}

// Query returns a query builder for Dictionary.
func (c *DictionaryClient) Query() *DictionaryQuery {
	return &DictionaryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDictionary},
		inters: c.Interceptors(),
	}
}

// Get returns a Dictionary entity by its id.
func (c *DictionaryClient) Get(ctx context.Context, id string) (*Dictionary, error) {
	return c.Query().Where(dictionary.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DictionaryClient) GetX(ctx context.Context, id string) *Dictionary {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryItems queries the items edge of a Dictionary.
func (c *DictionaryClient) QueryItems(d *Dictionary) *DictionaryItemQuery {
	query := (&DictionaryItemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := d.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dictionary.Table, dictionary.FieldID, id),
			sqlgraph.To(dictionary_item.Table, dictionary_item.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, dictionary.ItemsTable, dictionary.ItemsColumn),
		)
		fromV = sqlgraph.Neighbors(d.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DictionaryClient) Hooks() []Hook {
	hooks := c.hooks.Dictionary
	return append(hooks[:len(hooks):len(hooks)], dictionary.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *DictionaryClient) Interceptors() []Interceptor {
	return c.inters.Dictionary
}

func (c *DictionaryClient) mutate(ctx context.Context, m *DictionaryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DictionaryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DictionaryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DictionaryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DictionaryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Dictionary mutation op: %q", m.Op())
	}
}

// DictionaryItemClient is a client for the Dictionary_Item schema.
type DictionaryItemClient struct {
	config
}

// NewDictionaryItemClient returns a client for the Dictionary_Item from the given config.
func NewDictionaryItemClient(c config) *DictionaryItemClient {
	return &DictionaryItemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `dictionary_item.Hooks(f(g(h())))`.
func (c *DictionaryItemClient) Use(hooks ...Hook) {
	c.hooks.Dictionary_Item = append(c.hooks.Dictionary_Item, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `dictionary_item.Intercept(f(g(h())))`.
func (c *DictionaryItemClient) Intercept(interceptors ...Interceptor) {
	c.inters.Dictionary_Item = append(c.inters.Dictionary_Item, interceptors...)
}

// Create returns a builder for creating a Dictionary_Item entity.
func (c *DictionaryItemClient) Create() *DictionaryItemCreate {
	mutation := newDictionaryItemMutation(c.config, OpCreate)
	return &DictionaryItemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Dictionary_Item entities.
func (c *DictionaryItemClient) CreateBulk(builders ...*DictionaryItemCreate) *DictionaryItemCreateBulk {
	return &DictionaryItemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DictionaryItemClient) MapCreateBulk(slice any, setFunc func(*DictionaryItemCreate, int)) *DictionaryItemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DictionaryItemCreateBulk{err: fmt.Errorf("calling to DictionaryItemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DictionaryItemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DictionaryItemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Dictionary_Item.
func (c *DictionaryItemClient) Update() *DictionaryItemUpdate {
	mutation := newDictionaryItemMutation(c.config, OpUpdate)
	return &DictionaryItemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DictionaryItemClient) UpdateOne(di *Dictionary_Item) *DictionaryItemUpdateOne {
	mutation := newDictionaryItemMutation(c.config, OpUpdateOne, withDictionary_Item(di))
	return &DictionaryItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DictionaryItemClient) UpdateOneID(id string) *DictionaryItemUpdateOne {
	mutation := newDictionaryItemMutation(c.config, OpUpdateOne, withDictionary_ItemID(id))
	return &DictionaryItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Dictionary_Item.
func (c *DictionaryItemClient) Delete() *DictionaryItemDelete {
	mutation := newDictionaryItemMutation(c.config, OpDelete)
	return &DictionaryItemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DictionaryItemClient) DeleteOne(di *Dictionary_Item) *DictionaryItemDeleteOne {
	return c.DeleteOneID(di.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DictionaryItemClient) DeleteOneID(id string) *DictionaryItemDeleteOne {
	builder := c.Delete().Where(dictionary_item.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DictionaryItemDeleteOne{builder}
}

// Query returns a query builder for Dictionary_Item.
func (c *DictionaryItemClient) Query() *DictionaryItemQuery {
	return &DictionaryItemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDictionaryItem},
		inters: c.Interceptors(),
	}
}

// Get returns a Dictionary_Item entity by its id.
func (c *DictionaryItemClient) Get(ctx context.Context, id string) (*Dictionary_Item, error) {
	return c.Query().Where(dictionary_item.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DictionaryItemClient) GetX(ctx context.Context, id string) *Dictionary_Item {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDictionary queries the dictionary edge of a Dictionary_Item.
func (c *DictionaryItemClient) QueryDictionary(di *Dictionary_Item) *DictionaryQuery {
	query := (&DictionaryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := di.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(dictionary_item.Table, dictionary_item.FieldID, id),
			sqlgraph.To(dictionary.Table, dictionary.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, dictionary_item.DictionaryTable, dictionary_item.DictionaryColumn),
		)
		fromV = sqlgraph.Neighbors(di.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DictionaryItemClient) Hooks() []Hook {
	hooks := c.hooks.Dictionary_Item
	return append(hooks[:len(hooks):len(hooks)], dictionary_item.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *DictionaryItemClient) Interceptors() []Interceptor {
	return c.inters.Dictionary_Item
}

func (c *DictionaryItemClient) mutate(ctx context.Context, m *DictionaryItemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DictionaryItemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DictionaryItemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DictionaryItemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DictionaryItemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Dictionary_Item mutation op: %q", m.Op())
	}
}

// MenuClient is a client for the Menu schema.
type MenuClient struct {
	config
}

// NewMenuClient returns a client for the Menu from the given config.
func NewMenuClient(c config) *MenuClient {
	return &MenuClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `menu.Hooks(f(g(h())))`.
func (c *MenuClient) Use(hooks ...Hook) {
	c.hooks.Menu = append(c.hooks.Menu, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `menu.Intercept(f(g(h())))`.
func (c *MenuClient) Intercept(interceptors ...Interceptor) {
	c.inters.Menu = append(c.inters.Menu, interceptors...)
}

// Create returns a builder for creating a Menu entity.
func (c *MenuClient) Create() *MenuCreate {
	mutation := newMenuMutation(c.config, OpCreate)
	return &MenuCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Menu entities.
func (c *MenuClient) CreateBulk(builders ...*MenuCreate) *MenuCreateBulk {
	return &MenuCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MenuClient) MapCreateBulk(slice any, setFunc func(*MenuCreate, int)) *MenuCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MenuCreateBulk{err: fmt.Errorf("calling to MenuClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MenuCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MenuCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Menu.
func (c *MenuClient) Update() *MenuUpdate {
	mutation := newMenuMutation(c.config, OpUpdate)
	return &MenuUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MenuClient) UpdateOne(m *Menu) *MenuUpdateOne {
	mutation := newMenuMutation(c.config, OpUpdateOne, withMenu(m))
	return &MenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MenuClient) UpdateOneID(id string) *MenuUpdateOne {
	mutation := newMenuMutation(c.config, OpUpdateOne, withMenuID(id))
	return &MenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Menu.
func (c *MenuClient) Delete() *MenuDelete {
	mutation := newMenuMutation(c.config, OpDelete)
	return &MenuDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MenuClient) DeleteOne(m *Menu) *MenuDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MenuClient) DeleteOneID(id string) *MenuDeleteOne {
	builder := c.Delete().Where(menu.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MenuDeleteOne{builder}
}

// Query returns a query builder for Menu.
func (c *MenuClient) Query() *MenuQuery {
	return &MenuQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMenu},
		inters: c.Interceptors(),
	}
}

// Get returns a Menu entity by its id.
func (c *MenuClient) Get(ctx context.Context, id string) (*Menu, error) {
	return c.Query().Where(menu.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MenuClient) GetX(ctx context.Context, id string) *Menu {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryParent queries the parent edge of a Menu.
func (c *MenuClient) QueryParent(m *Menu) *MenuQuery {
	query := (&MenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, menu.ParentTable, menu.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Menu.
func (c *MenuClient) QueryChildren(m *Menu) *MenuQuery {
	query := (&MenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, menu.ChildrenTable, menu.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRolesMenus queries the roles_menus edge of a Menu.
func (c *MenuClient) QueryRolesMenus(m *Menu) *RoleMenuQuery {
	query := (&RoleMenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(menu.Table, menu.FieldID, id),
			sqlgraph.To(role_menu.Table, role_menu.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, menu.RolesMenusTable, menu.RolesMenusColumn),
		)
		fromV = sqlgraph.Neighbors(m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *MenuClient) Hooks() []Hook {
	hooks := c.hooks.Menu
	return append(hooks[:len(hooks):len(hooks)], menu.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *MenuClient) Interceptors() []Interceptor {
	return c.inters.Menu
}

func (c *MenuClient) mutate(ctx context.Context, m *MenuMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MenuCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MenuUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MenuDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Menu mutation op: %q", m.Op())
	}
}

// OrganizationClient is a client for the Organization schema.
type OrganizationClient struct {
	config
}

// NewOrganizationClient returns a client for the Organization from the given config.
func NewOrganizationClient(c config) *OrganizationClient {
	return &OrganizationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `organization.Hooks(f(g(h())))`.
func (c *OrganizationClient) Use(hooks ...Hook) {
	c.hooks.Organization = append(c.hooks.Organization, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `organization.Intercept(f(g(h())))`.
func (c *OrganizationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Organization = append(c.inters.Organization, interceptors...)
}

// Create returns a builder for creating a Organization entity.
func (c *OrganizationClient) Create() *OrganizationCreate {
	mutation := newOrganizationMutation(c.config, OpCreate)
	return &OrganizationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Organization entities.
func (c *OrganizationClient) CreateBulk(builders ...*OrganizationCreate) *OrganizationCreateBulk {
	return &OrganizationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OrganizationClient) MapCreateBulk(slice any, setFunc func(*OrganizationCreate, int)) *OrganizationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OrganizationCreateBulk{err: fmt.Errorf("calling to OrganizationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OrganizationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OrganizationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Organization.
func (c *OrganizationClient) Update() *OrganizationUpdate {
	mutation := newOrganizationMutation(c.config, OpUpdate)
	return &OrganizationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OrganizationClient) UpdateOne(o *Organization) *OrganizationUpdateOne {
	mutation := newOrganizationMutation(c.config, OpUpdateOne, withOrganization(o))
	return &OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OrganizationClient) UpdateOneID(id string) *OrganizationUpdateOne {
	mutation := newOrganizationMutation(c.config, OpUpdateOne, withOrganizationID(id))
	return &OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Organization.
func (c *OrganizationClient) Delete() *OrganizationDelete {
	mutation := newOrganizationMutation(c.config, OpDelete)
	return &OrganizationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OrganizationClient) DeleteOne(o *Organization) *OrganizationDeleteOne {
	return c.DeleteOneID(o.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OrganizationClient) DeleteOneID(id string) *OrganizationDeleteOne {
	builder := c.Delete().Where(organization.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OrganizationDeleteOne{builder}
}

// Query returns a query builder for Organization.
func (c *OrganizationClient) Query() *OrganizationQuery {
	return &OrganizationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOrganization},
		inters: c.Interceptors(),
	}
}

// Get returns a Organization entity by its id.
func (c *OrganizationClient) Get(ctx context.Context, id string) (*Organization, error) {
	return c.Query().Where(organization.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OrganizationClient) GetX(ctx context.Context, id string) *Organization {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryParent queries the parent edge of a Organization.
func (c *OrganizationClient) QueryParent(o *Organization) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, organization.ParentTable, organization.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Organization.
func (c *OrganizationClient) QueryChildren(o *Organization) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.ChildrenTable, organization.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRolesOrganizations queries the roles_organizations edge of a Organization.
func (c *OrganizationClient) QueryRolesOrganizations(o *Organization) *RoleOrganizationQuery {
	query := (&RoleOrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(role_organization.Table, role_organization.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, organization.RolesOrganizationsTable, organization.RolesOrganizationsColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStaffs queries the staffs edge of a Organization.
func (c *OrganizationClient) QueryStaffs(o *Organization) *StaffQuery {
	query := (&StaffClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := o.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(organization.Table, organization.FieldID, id),
			sqlgraph.To(staff.Table, staff.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, organization.StaffsTable, organization.StaffsColumn),
		)
		fromV = sqlgraph.Neighbors(o.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *OrganizationClient) Hooks() []Hook {
	hooks := c.hooks.Organization
	return append(hooks[:len(hooks):len(hooks)], organization.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *OrganizationClient) Interceptors() []Interceptor {
	return c.inters.Organization
}

func (c *OrganizationClient) mutate(ctx context.Context, m *OrganizationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OrganizationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OrganizationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OrganizationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Organization mutation op: %q", m.Op())
	}
}

// PositionClient is a client for the Position schema.
type PositionClient struct {
	config
}

// NewPositionClient returns a client for the Position from the given config.
func NewPositionClient(c config) *PositionClient {
	return &PositionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `position.Hooks(f(g(h())))`.
func (c *PositionClient) Use(hooks ...Hook) {
	c.hooks.Position = append(c.hooks.Position, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `position.Intercept(f(g(h())))`.
func (c *PositionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Position = append(c.inters.Position, interceptors...)
}

// Create returns a builder for creating a Position entity.
func (c *PositionClient) Create() *PositionCreate {
	mutation := newPositionMutation(c.config, OpCreate)
	return &PositionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Position entities.
func (c *PositionClient) CreateBulk(builders ...*PositionCreate) *PositionCreateBulk {
	return &PositionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PositionClient) MapCreateBulk(slice any, setFunc func(*PositionCreate, int)) *PositionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PositionCreateBulk{err: fmt.Errorf("calling to PositionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PositionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PositionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Position.
func (c *PositionClient) Update() *PositionUpdate {
	mutation := newPositionMutation(c.config, OpUpdate)
	return &PositionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PositionClient) UpdateOne(po *Position) *PositionUpdateOne {
	mutation := newPositionMutation(c.config, OpUpdateOne, withPosition(po))
	return &PositionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PositionClient) UpdateOneID(id string) *PositionUpdateOne {
	mutation := newPositionMutation(c.config, OpUpdateOne, withPositionID(id))
	return &PositionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Position.
func (c *PositionClient) Delete() *PositionDelete {
	mutation := newPositionMutation(c.config, OpDelete)
	return &PositionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PositionClient) DeleteOne(po *Position) *PositionDeleteOne {
	return c.DeleteOneID(po.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PositionClient) DeleteOneID(id string) *PositionDeleteOne {
	builder := c.Delete().Where(position.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PositionDeleteOne{builder}
}

// Query returns a query builder for Position.
func (c *PositionClient) Query() *PositionQuery {
	return &PositionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePosition},
		inters: c.Interceptors(),
	}
}

// Get returns a Position entity by its id.
func (c *PositionClient) Get(ctx context.Context, id string) (*Position, error) {
	return c.Query().Where(position.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PositionClient) GetX(ctx context.Context, id string) *Position {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStaffsPositions queries the staffs_positions edge of a Position.
func (c *PositionClient) QueryStaffsPositions(po *Position) *StaffPositionQuery {
	query := (&StaffPositionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(position.Table, position.FieldID, id),
			sqlgraph.To(staff_position.Table, staff_position.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, position.StaffsPositionsTable, position.StaffsPositionsColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PositionClient) Hooks() []Hook {
	hooks := c.hooks.Position
	return append(hooks[:len(hooks):len(hooks)], position.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PositionClient) Interceptors() []Interceptor {
	return c.inters.Position
}

func (c *PositionClient) mutate(ctx context.Context, m *PositionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PositionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PositionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PositionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PositionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Position mutation op: %q", m.Op())
	}
}

// RoleClient is a client for the Role schema.
type RoleClient struct {
	config
}

// NewRoleClient returns a client for the Role from the given config.
func NewRoleClient(c config) *RoleClient {
	return &RoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `role.Hooks(f(g(h())))`.
func (c *RoleClient) Use(hooks ...Hook) {
	c.hooks.Role = append(c.hooks.Role, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `role.Intercept(f(g(h())))`.
func (c *RoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.Role = append(c.inters.Role, interceptors...)
}

// Create returns a builder for creating a Role entity.
func (c *RoleClient) Create() *RoleCreate {
	mutation := newRoleMutation(c.config, OpCreate)
	return &RoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Role entities.
func (c *RoleClient) CreateBulk(builders ...*RoleCreate) *RoleCreateBulk {
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RoleClient) MapCreateBulk(slice any, setFunc func(*RoleCreate, int)) *RoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RoleCreateBulk{err: fmt.Errorf("calling to RoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Role.
func (c *RoleClient) Update() *RoleUpdate {
	mutation := newRoleMutation(c.config, OpUpdate)
	return &RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoleClient) UpdateOne(r *Role) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRole(r))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoleClient) UpdateOneID(id string) *RoleUpdateOne {
	mutation := newRoleMutation(c.config, OpUpdateOne, withRoleID(id))
	return &RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Role.
func (c *RoleClient) Delete() *RoleDelete {
	mutation := newRoleMutation(c.config, OpDelete)
	return &RoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoleClient) DeleteOne(r *Role) *RoleDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoleClient) DeleteOneID(id string) *RoleDeleteOne {
	builder := c.Delete().Where(role.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoleDeleteOne{builder}
}

// Query returns a query builder for Role.
func (c *RoleClient) Query() *RoleQuery {
	return &RoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRole},
		inters: c.Interceptors(),
	}
}

// Get returns a Role entity by its id.
func (c *RoleClient) Get(ctx context.Context, id string) (*Role, error) {
	return c.Query().Where(role.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoleClient) GetX(ctx context.Context, id string) *Role {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRolesMenus queries the roles_menus edge of a Role.
func (c *RoleClient) QueryRolesMenus(r *Role) *RoleMenuQuery {
	query := (&RoleMenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(role_menu.Table, role_menu.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, role.RolesMenusTable, role.RolesMenusColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRolesOrganizations queries the roles_organizations edge of a Role.
func (c *RoleClient) QueryRolesOrganizations(r *Role) *RoleOrganizationQuery {
	query := (&RoleOrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(role_organization.Table, role_organization.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, role.RolesOrganizationsTable, role.RolesOrganizationsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStaffsRoles queries the staffs_roles edge of a Role.
func (c *RoleClient) QueryStaffsRoles(r *Role) *StaffRoleQuery {
	query := (&StaffRoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role.Table, role.FieldID, id),
			sqlgraph.To(staff_role.Table, staff_role.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, role.StaffsRolesTable, role.StaffsRolesColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoleClient) Hooks() []Hook {
	hooks := c.hooks.Role
	return append(hooks[:len(hooks):len(hooks)], role.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *RoleClient) Interceptors() []Interceptor {
	return c.inters.Role
}

func (c *RoleClient) mutate(ctx context.Context, m *RoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Role mutation op: %q", m.Op())
	}
}

// RoleMenuClient is a client for the Role_Menu schema.
type RoleMenuClient struct {
	config
}

// NewRoleMenuClient returns a client for the Role_Menu from the given config.
func NewRoleMenuClient(c config) *RoleMenuClient {
	return &RoleMenuClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `role_menu.Hooks(f(g(h())))`.
func (c *RoleMenuClient) Use(hooks ...Hook) {
	c.hooks.Role_Menu = append(c.hooks.Role_Menu, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `role_menu.Intercept(f(g(h())))`.
func (c *RoleMenuClient) Intercept(interceptors ...Interceptor) {
	c.inters.Role_Menu = append(c.inters.Role_Menu, interceptors...)
}

// Create returns a builder for creating a Role_Menu entity.
func (c *RoleMenuClient) Create() *RoleMenuCreate {
	mutation := newRoleMenuMutation(c.config, OpCreate)
	return &RoleMenuCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Role_Menu entities.
func (c *RoleMenuClient) CreateBulk(builders ...*RoleMenuCreate) *RoleMenuCreateBulk {
	return &RoleMenuCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RoleMenuClient) MapCreateBulk(slice any, setFunc func(*RoleMenuCreate, int)) *RoleMenuCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RoleMenuCreateBulk{err: fmt.Errorf("calling to RoleMenuClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RoleMenuCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RoleMenuCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Role_Menu.
func (c *RoleMenuClient) Update() *RoleMenuUpdate {
	mutation := newRoleMenuMutation(c.config, OpUpdate)
	return &RoleMenuUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoleMenuClient) UpdateOne(rm *Role_Menu) *RoleMenuUpdateOne {
	mutation := newRoleMenuMutation(c.config, OpUpdateOne, withRole_Menu(rm))
	return &RoleMenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoleMenuClient) UpdateOneID(id string) *RoleMenuUpdateOne {
	mutation := newRoleMenuMutation(c.config, OpUpdateOne, withRole_MenuID(id))
	return &RoleMenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Role_Menu.
func (c *RoleMenuClient) Delete() *RoleMenuDelete {
	mutation := newRoleMenuMutation(c.config, OpDelete)
	return &RoleMenuDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoleMenuClient) DeleteOne(rm *Role_Menu) *RoleMenuDeleteOne {
	return c.DeleteOneID(rm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoleMenuClient) DeleteOneID(id string) *RoleMenuDeleteOne {
	builder := c.Delete().Where(role_menu.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoleMenuDeleteOne{builder}
}

// Query returns a query builder for Role_Menu.
func (c *RoleMenuClient) Query() *RoleMenuQuery {
	return &RoleMenuQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRoleMenu},
		inters: c.Interceptors(),
	}
}

// Get returns a Role_Menu entity by its id.
func (c *RoleMenuClient) Get(ctx context.Context, id string) (*Role_Menu, error) {
	return c.Query().Where(role_menu.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoleMenuClient) GetX(ctx context.Context, id string) *Role_Menu {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRoles queries the roles edge of a Role_Menu.
func (c *RoleMenuClient) QueryRoles(rm *Role_Menu) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role_menu.Table, role_menu.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, role_menu.RolesTable, role_menu.RolesColumn),
		)
		fromV = sqlgraph.Neighbors(rm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMenus queries the menus edge of a Role_Menu.
func (c *RoleMenuClient) QueryMenus(rm *Role_Menu) *MenuQuery {
	query := (&MenuClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := rm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role_menu.Table, role_menu.FieldID, id),
			sqlgraph.To(menu.Table, menu.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, role_menu.MenusTable, role_menu.MenusColumn),
		)
		fromV = sqlgraph.Neighbors(rm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoleMenuClient) Hooks() []Hook {
	hooks := c.hooks.Role_Menu
	return append(hooks[:len(hooks):len(hooks)], role_menu.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *RoleMenuClient) Interceptors() []Interceptor {
	return c.inters.Role_Menu
}

func (c *RoleMenuClient) mutate(ctx context.Context, m *RoleMenuMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoleMenuCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoleMenuUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoleMenuUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoleMenuDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Role_Menu mutation op: %q", m.Op())
	}
}

// RoleOrganizationClient is a client for the Role_Organization schema.
type RoleOrganizationClient struct {
	config
}

// NewRoleOrganizationClient returns a client for the Role_Organization from the given config.
func NewRoleOrganizationClient(c config) *RoleOrganizationClient {
	return &RoleOrganizationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `role_organization.Hooks(f(g(h())))`.
func (c *RoleOrganizationClient) Use(hooks ...Hook) {
	c.hooks.Role_Organization = append(c.hooks.Role_Organization, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `role_organization.Intercept(f(g(h())))`.
func (c *RoleOrganizationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Role_Organization = append(c.inters.Role_Organization, interceptors...)
}

// Create returns a builder for creating a Role_Organization entity.
func (c *RoleOrganizationClient) Create() *RoleOrganizationCreate {
	mutation := newRoleOrganizationMutation(c.config, OpCreate)
	return &RoleOrganizationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Role_Organization entities.
func (c *RoleOrganizationClient) CreateBulk(builders ...*RoleOrganizationCreate) *RoleOrganizationCreateBulk {
	return &RoleOrganizationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RoleOrganizationClient) MapCreateBulk(slice any, setFunc func(*RoleOrganizationCreate, int)) *RoleOrganizationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RoleOrganizationCreateBulk{err: fmt.Errorf("calling to RoleOrganizationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RoleOrganizationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RoleOrganizationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Role_Organization.
func (c *RoleOrganizationClient) Update() *RoleOrganizationUpdate {
	mutation := newRoleOrganizationMutation(c.config, OpUpdate)
	return &RoleOrganizationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RoleOrganizationClient) UpdateOne(ro *Role_Organization) *RoleOrganizationUpdateOne {
	mutation := newRoleOrganizationMutation(c.config, OpUpdateOne, withRole_Organization(ro))
	return &RoleOrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RoleOrganizationClient) UpdateOneID(id string) *RoleOrganizationUpdateOne {
	mutation := newRoleOrganizationMutation(c.config, OpUpdateOne, withRole_OrganizationID(id))
	return &RoleOrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Role_Organization.
func (c *RoleOrganizationClient) Delete() *RoleOrganizationDelete {
	mutation := newRoleOrganizationMutation(c.config, OpDelete)
	return &RoleOrganizationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RoleOrganizationClient) DeleteOne(ro *Role_Organization) *RoleOrganizationDeleteOne {
	return c.DeleteOneID(ro.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RoleOrganizationClient) DeleteOneID(id string) *RoleOrganizationDeleteOne {
	builder := c.Delete().Where(role_organization.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RoleOrganizationDeleteOne{builder}
}

// Query returns a query builder for Role_Organization.
func (c *RoleOrganizationClient) Query() *RoleOrganizationQuery {
	return &RoleOrganizationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRoleOrganization},
		inters: c.Interceptors(),
	}
}

// Get returns a Role_Organization entity by its id.
func (c *RoleOrganizationClient) Get(ctx context.Context, id string) (*Role_Organization, error) {
	return c.Query().Where(role_organization.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RoleOrganizationClient) GetX(ctx context.Context, id string) *Role_Organization {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryRoles queries the roles edge of a Role_Organization.
func (c *RoleOrganizationClient) QueryRoles(ro *Role_Organization) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ro.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role_organization.Table, role_organization.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, role_organization.RolesTable, role_organization.RolesColumn),
		)
		fromV = sqlgraph.Neighbors(ro.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryOrganizations queries the organizations edge of a Role_Organization.
func (c *RoleOrganizationClient) QueryOrganizations(ro *Role_Organization) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ro.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(role_organization.Table, role_organization.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, role_organization.OrganizationsTable, role_organization.OrganizationsColumn),
		)
		fromV = sqlgraph.Neighbors(ro.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RoleOrganizationClient) Hooks() []Hook {
	hooks := c.hooks.Role_Organization
	return append(hooks[:len(hooks):len(hooks)], role_organization.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *RoleOrganizationClient) Interceptors() []Interceptor {
	return c.inters.Role_Organization
}

func (c *RoleOrganizationClient) mutate(ctx context.Context, m *RoleOrganizationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RoleOrganizationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RoleOrganizationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RoleOrganizationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RoleOrganizationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Role_Organization mutation op: %q", m.Op())
	}
}

// StaffClient is a client for the Staff schema.
type StaffClient struct {
	config
}

// NewStaffClient returns a client for the Staff from the given config.
func NewStaffClient(c config) *StaffClient {
	return &StaffClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `staff.Hooks(f(g(h())))`.
func (c *StaffClient) Use(hooks ...Hook) {
	c.hooks.Staff = append(c.hooks.Staff, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `staff.Intercept(f(g(h())))`.
func (c *StaffClient) Intercept(interceptors ...Interceptor) {
	c.inters.Staff = append(c.inters.Staff, interceptors...)
}

// Create returns a builder for creating a Staff entity.
func (c *StaffClient) Create() *StaffCreate {
	mutation := newStaffMutation(c.config, OpCreate)
	return &StaffCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Staff entities.
func (c *StaffClient) CreateBulk(builders ...*StaffCreate) *StaffCreateBulk {
	return &StaffCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StaffClient) MapCreateBulk(slice any, setFunc func(*StaffCreate, int)) *StaffCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StaffCreateBulk{err: fmt.Errorf("calling to StaffClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StaffCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StaffCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Staff.
func (c *StaffClient) Update() *StaffUpdate {
	mutation := newStaffMutation(c.config, OpUpdate)
	return &StaffUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StaffClient) UpdateOne(s *Staff) *StaffUpdateOne {
	mutation := newStaffMutation(c.config, OpUpdateOne, withStaff(s))
	return &StaffUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StaffClient) UpdateOneID(id string) *StaffUpdateOne {
	mutation := newStaffMutation(c.config, OpUpdateOne, withStaffID(id))
	return &StaffUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Staff.
func (c *StaffClient) Delete() *StaffDelete {
	mutation := newStaffMutation(c.config, OpDelete)
	return &StaffDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StaffClient) DeleteOne(s *Staff) *StaffDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StaffClient) DeleteOneID(id string) *StaffDeleteOne {
	builder := c.Delete().Where(staff.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StaffDeleteOne{builder}
}

// Query returns a query builder for Staff.
func (c *StaffClient) Query() *StaffQuery {
	return &StaffQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStaff},
		inters: c.Interceptors(),
	}
}

// Get returns a Staff entity by its id.
func (c *StaffClient) Get(ctx context.Context, id string) (*Staff, error) {
	return c.Query().Where(staff.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StaffClient) GetX(ctx context.Context, id string) *Staff {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOrganization queries the organization edge of a Staff.
func (c *StaffClient) QueryOrganization(s *Staff) *OrganizationQuery {
	query := (&OrganizationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(staff.Table, staff.FieldID, id),
			sqlgraph.To(organization.Table, organization.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, staff.OrganizationTable, staff.OrganizationColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStaffsRoles queries the staffs_roles edge of a Staff.
func (c *StaffClient) QueryStaffsRoles(s *Staff) *StaffRoleQuery {
	query := (&StaffRoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(staff.Table, staff.FieldID, id),
			sqlgraph.To(staff_role.Table, staff_role.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, staff.StaffsRolesTable, staff.StaffsRolesColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryStaffsPositions queries the staffs_positions edge of a Staff.
func (c *StaffClient) QueryStaffsPositions(s *Staff) *StaffPositionQuery {
	query := (&StaffPositionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(staff.Table, staff.FieldID, id),
			sqlgraph.To(staff_position.Table, staff_position.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, staff.StaffsPositionsTable, staff.StaffsPositionsColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StaffClient) Hooks() []Hook {
	hooks := c.hooks.Staff
	return append(hooks[:len(hooks):len(hooks)], staff.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *StaffClient) Interceptors() []Interceptor {
	return c.inters.Staff
}

func (c *StaffClient) mutate(ctx context.Context, m *StaffMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StaffCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StaffUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StaffUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StaffDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Staff mutation op: %q", m.Op())
	}
}

// StaffPositionClient is a client for the Staff_Position schema.
type StaffPositionClient struct {
	config
}

// NewStaffPositionClient returns a client for the Staff_Position from the given config.
func NewStaffPositionClient(c config) *StaffPositionClient {
	return &StaffPositionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `staff_position.Hooks(f(g(h())))`.
func (c *StaffPositionClient) Use(hooks ...Hook) {
	c.hooks.Staff_Position = append(c.hooks.Staff_Position, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `staff_position.Intercept(f(g(h())))`.
func (c *StaffPositionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Staff_Position = append(c.inters.Staff_Position, interceptors...)
}

// Create returns a builder for creating a Staff_Position entity.
func (c *StaffPositionClient) Create() *StaffPositionCreate {
	mutation := newStaffPositionMutation(c.config, OpCreate)
	return &StaffPositionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Staff_Position entities.
func (c *StaffPositionClient) CreateBulk(builders ...*StaffPositionCreate) *StaffPositionCreateBulk {
	return &StaffPositionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StaffPositionClient) MapCreateBulk(slice any, setFunc func(*StaffPositionCreate, int)) *StaffPositionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StaffPositionCreateBulk{err: fmt.Errorf("calling to StaffPositionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StaffPositionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StaffPositionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Staff_Position.
func (c *StaffPositionClient) Update() *StaffPositionUpdate {
	mutation := newStaffPositionMutation(c.config, OpUpdate)
	return &StaffPositionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StaffPositionClient) UpdateOne(sp *Staff_Position) *StaffPositionUpdateOne {
	mutation := newStaffPositionMutation(c.config, OpUpdateOne, withStaff_Position(sp))
	return &StaffPositionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StaffPositionClient) UpdateOneID(id string) *StaffPositionUpdateOne {
	mutation := newStaffPositionMutation(c.config, OpUpdateOne, withStaff_PositionID(id))
	return &StaffPositionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Staff_Position.
func (c *StaffPositionClient) Delete() *StaffPositionDelete {
	mutation := newStaffPositionMutation(c.config, OpDelete)
	return &StaffPositionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StaffPositionClient) DeleteOne(sp *Staff_Position) *StaffPositionDeleteOne {
	return c.DeleteOneID(sp.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StaffPositionClient) DeleteOneID(id string) *StaffPositionDeleteOne {
	builder := c.Delete().Where(staff_position.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StaffPositionDeleteOne{builder}
}

// Query returns a query builder for Staff_Position.
func (c *StaffPositionClient) Query() *StaffPositionQuery {
	return &StaffPositionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStaffPosition},
		inters: c.Interceptors(),
	}
}

// Get returns a Staff_Position entity by its id.
func (c *StaffPositionClient) Get(ctx context.Context, id string) (*Staff_Position, error) {
	return c.Query().Where(staff_position.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StaffPositionClient) GetX(ctx context.Context, id string) *Staff_Position {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStaffs queries the staffs edge of a Staff_Position.
func (c *StaffPositionClient) QueryStaffs(sp *Staff_Position) *StaffQuery {
	query := (&StaffClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(staff_position.Table, staff_position.FieldID, id),
			sqlgraph.To(staff.Table, staff.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, staff_position.StaffsTable, staff_position.StaffsColumn),
		)
		fromV = sqlgraph.Neighbors(sp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPositions queries the positions edge of a Staff_Position.
func (c *StaffPositionClient) QueryPositions(sp *Staff_Position) *PositionQuery {
	query := (&PositionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sp.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(staff_position.Table, staff_position.FieldID, id),
			sqlgraph.To(position.Table, position.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, staff_position.PositionsTable, staff_position.PositionsColumn),
		)
		fromV = sqlgraph.Neighbors(sp.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StaffPositionClient) Hooks() []Hook {
	hooks := c.hooks.Staff_Position
	return append(hooks[:len(hooks):len(hooks)], staff_position.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *StaffPositionClient) Interceptors() []Interceptor {
	return c.inters.Staff_Position
}

func (c *StaffPositionClient) mutate(ctx context.Context, m *StaffPositionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StaffPositionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StaffPositionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StaffPositionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StaffPositionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Staff_Position mutation op: %q", m.Op())
	}
}

// StaffRoleClient is a client for the Staff_Role schema.
type StaffRoleClient struct {
	config
}

// NewStaffRoleClient returns a client for the Staff_Role from the given config.
func NewStaffRoleClient(c config) *StaffRoleClient {
	return &StaffRoleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `staff_role.Hooks(f(g(h())))`.
func (c *StaffRoleClient) Use(hooks ...Hook) {
	c.hooks.Staff_Role = append(c.hooks.Staff_Role, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `staff_role.Intercept(f(g(h())))`.
func (c *StaffRoleClient) Intercept(interceptors ...Interceptor) {
	c.inters.Staff_Role = append(c.inters.Staff_Role, interceptors...)
}

// Create returns a builder for creating a Staff_Role entity.
func (c *StaffRoleClient) Create() *StaffRoleCreate {
	mutation := newStaffRoleMutation(c.config, OpCreate)
	return &StaffRoleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Staff_Role entities.
func (c *StaffRoleClient) CreateBulk(builders ...*StaffRoleCreate) *StaffRoleCreateBulk {
	return &StaffRoleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *StaffRoleClient) MapCreateBulk(slice any, setFunc func(*StaffRoleCreate, int)) *StaffRoleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &StaffRoleCreateBulk{err: fmt.Errorf("calling to StaffRoleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*StaffRoleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &StaffRoleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Staff_Role.
func (c *StaffRoleClient) Update() *StaffRoleUpdate {
	mutation := newStaffRoleMutation(c.config, OpUpdate)
	return &StaffRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *StaffRoleClient) UpdateOne(sr *Staff_Role) *StaffRoleUpdateOne {
	mutation := newStaffRoleMutation(c.config, OpUpdateOne, withStaff_Role(sr))
	return &StaffRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *StaffRoleClient) UpdateOneID(id string) *StaffRoleUpdateOne {
	mutation := newStaffRoleMutation(c.config, OpUpdateOne, withStaff_RoleID(id))
	return &StaffRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Staff_Role.
func (c *StaffRoleClient) Delete() *StaffRoleDelete {
	mutation := newStaffRoleMutation(c.config, OpDelete)
	return &StaffRoleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *StaffRoleClient) DeleteOne(sr *Staff_Role) *StaffRoleDeleteOne {
	return c.DeleteOneID(sr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *StaffRoleClient) DeleteOneID(id string) *StaffRoleDeleteOne {
	builder := c.Delete().Where(staff_role.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &StaffRoleDeleteOne{builder}
}

// Query returns a query builder for Staff_Role.
func (c *StaffRoleClient) Query() *StaffRoleQuery {
	return &StaffRoleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeStaffRole},
		inters: c.Interceptors(),
	}
}

// Get returns a Staff_Role entity by its id.
func (c *StaffRoleClient) Get(ctx context.Context, id string) (*Staff_Role, error) {
	return c.Query().Where(staff_role.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *StaffRoleClient) GetX(ctx context.Context, id string) *Staff_Role {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryStaffs queries the staffs edge of a Staff_Role.
func (c *StaffRoleClient) QueryStaffs(sr *Staff_Role) *StaffQuery {
	query := (&StaffClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(staff_role.Table, staff_role.FieldID, id),
			sqlgraph.To(staff.Table, staff.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, staff_role.StaffsTable, staff_role.StaffsColumn),
		)
		fromV = sqlgraph.Neighbors(sr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoles queries the roles edge of a Staff_Role.
func (c *StaffRoleClient) QueryRoles(sr *Staff_Role) *RoleQuery {
	query := (&RoleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := sr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(staff_role.Table, staff_role.FieldID, id),
			sqlgraph.To(role.Table, role.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, staff_role.RolesTable, staff_role.RolesColumn),
		)
		fromV = sqlgraph.Neighbors(sr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *StaffRoleClient) Hooks() []Hook {
	hooks := c.hooks.Staff_Role
	return append(hooks[:len(hooks):len(hooks)], staff_role.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *StaffRoleClient) Interceptors() []Interceptor {
	return c.inters.Staff_Role
}

func (c *StaffRoleClient) mutate(ctx context.Context, m *StaffRoleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&StaffRoleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&StaffRoleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&StaffRoleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&StaffRoleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Staff_Role mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Dictionary, Dictionary_Item, Menu, Organization, Position, Role, Role_Menu,
		Role_Organization, Staff, Staff_Position, Staff_Role []ent.Hook
	}
	inters struct {
		Dictionary, Dictionary_Item, Menu, Organization, Position, Role, Role_Menu,
		Role_Organization, Staff, Staff_Position, Staff_Role []ent.Interceptor
	}
)
